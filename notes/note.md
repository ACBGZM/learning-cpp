基本语法

面向对象

内存管理

STL

C++ 11







## C++ 基础

#### 内存空间

|             单位：Byte             | x86 sizeof() | x64 sizeof() |
| :--------------------------------: | :----------: | :----------: |
|                指针                |      4       |      8       |
|                bool                |      1       |              |
|                char                |      1       |              |
|                int                 |      4       |              |
|                long                |      4       |              |
|             long long              |      8       |              |
|               float                |      4       |              |
|               double               |      8       |              |
|                enum                |      4       |              |
|              空struct              |      1       |              |
|     struct{int,int,char,char}      |      12      |              |
|   struct{double, int, int, char}   |      24      |              |
| struct{int, long long, int, char*} |   32(4848)   |   24(4844)   |
| struct{int, int, long long, char*} |   24(4488)   |   24(4484)   |

###### 整型

- 一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节（Byte）一样(1字节)
- 其它字符类型用于扩展字符集，wchar_t确保可以存放机器最大扩展字符集中的任意一个字符，char16_t和char32_t为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）
- 除了bool和扩充的char类型，其他整型可以分为带符号的和无符号的两种，加上unsigned的无符号整型所有bit都用来表示值，所以无符号整型只能表示≥0的值

###### 机器实现

- 可寻址最小内存块：字节（byte），存储的基本单元：字（word）
- x32，x64指的都是字长。在32位机器：1word=4byte=32bit，在64位机器：1word=8byte=64bit
- 计算机将每个字节（byte）跟一个地址关联起来。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据占的地址数，以及如何解释这些地址的内容

###### 浮点型

- 通常，float以1个字（32bit）表示，double以2个字（64bit）表示，long double以3或4个字表示（96或128bit）。
- 通常，float和double分别有7和16个有效位，long double则常用于有特殊浮点要求的硬件，精度跟具体实现有关。





#### 位、字节、地址

###### 概念

- 位：最小的<u>存储单位</u>是bit，存储一个二进制位
- 字节：以8个bit组成一个Byte，作为<u>存储单元</u>，是支持计算机存、取数据的最小单位
- 地址：变量占用空间的起始地址，在分配时决定，之后不再改变、直到变量撤销。地址值是一个常量

###### 使用

```c++
int a;
int* p = &a;
a = 1;
// &a = 0x23;
```

- int* 是一种地址类型，p=0x23，*p=1。

###### 设置 0x67a9 的整型变量的值为 0xaa66

```c++
int* ptr;
ptr = (int*)0x67a9;
*ptr = 0xaa66;
```






#### struct

<u>结构体在声明时不会开辟空间，在结构体实例化变量时再开辟空间</u>。

###### 给struct中的静态数组赋值

```c++
struct MyStruct{
    char str[100];
    int size;
}

int main(){
    MyStruct mystruct1;
    MyStruct mystruct2;
    MyStruct mystruct3;

    // strcpy的第二个参数是const char*类型，适用于把常量区的数组拷贝给struct
    strcpy(mystruct1.str, "helloworld");

    char* a = (char*)"helloworld";	// a指向常量区字符串
    strcpy(mystruct2.str, a);		// 把常量区字符串的值拷贝到类的内存中

    // 对于栈区的数组拷贝给struct，需要手动赋值
    char str_stack[6] = { 'h', 'e', 'l', 'l', 'o', '\0' };
    for (int i = 0;i < 6;i++)
    {
        mystruct3.str[i] = str_stack[i];
    }

    printf("%s, %d\n", mystruct1.str, mystruct1.size);
    printf("%s, %d\n", mystruct2.str, mystruct2.size);
    printf("%s, %d\n", mystruct3.str, mystruct3.size);
    return 0;
}
```





#### struct内存对齐

https://www.cnblogs.com/alantu2018/p/8460761.html

```c++
struct ss0{  
    char a[15]; //占15个字节，从0开始偏移，所以下面的int是从15开始偏移  
    int x;//偏移量 0x15+1=16  
}s1;  
cout<<sizeof(s1)<<endl; //结果为20字节  

struct ss1    
{  
    char a[15]; // 0-15
    int x; //偏移量 16字节,16-20
    char b; //偏移量 21字节,20-21  
}s2; //结果为21字节，按最大基本类型对齐，补充到24字节  
cout<<sizeof(s2)<<endl; //结果为24字节  

struct  ss2  
{  
    char a[15];  // 0-15
    int x;  // 16-20
    double b; // 24-32
    char c; // 32-33
}s3;//共33字节,按最大基本类型对齐，补充到40字节（整除8）  
cout<<sizeof(s3)<<endl; //结果为40字节


#pragma pack(push)  
#pragma pack(2)  
struct  
{  
    char a; //偏移0，1字节,0-1
    struct ss0 b; // 偏移1+1=2,20字节,2-22
    char f; //偏移22,1字节,22-23
    struct ss1 c;//偏移23+1,24字节,24-48
    char g;//偏移48,1字节,48-49
    struct ss2 d;//偏移49+1,40字节,50-90
    char e;//偏移90,1字节,90-91
}s7;//共91字节，不能整除2，所以补充到92字节  
cout<<"here:"<<sizeof(s7)<<endl;  
#pragma pack(pop)  
```



```c++
struct A  
{  
public:  
    int i;  //偏移0；4字节，0-4
    union U  
    {  
        char buff[13];  
        double i;  
    }u; //偏移4，不能整除sizeof(double)，所以偏移需要补充到8；16字节，8-24 
  
    void foo(){}      			// 函数不算空间
    typedef char* (*f)(void*);  // 函数指针不算空间
    char d;//偏移24；大小1字节，24-25
    enum{red , green, blue}color;//偏移25，补充到28；大小4字节，28-32 
    char e;//偏移32；大小1字节，32-33
}a;//大小33字节，不能整除sizeof(double)，补充到40字节
```

- 目的：提高内存的访问效率。如intel 32位CPU，每个总线周期都是从偶地址开始读内存，如果数据存放地址不是从偶数开始，则可能出现两个总线周期才能读取到想要的数据。
  - 数据占用内存的大小取决于数据本身的大小和其字节对齐方式，所谓对齐方式即数据在内存中存储地址的起始偏移应该满足的一个条件。比如说，一个int数据占用4个字节，如果该数据 的偏移是0x00000003，那么CPU就要先取1B、再取2B、最后取1B，三次取数据组合成一个int类型。
    - 为什么不能取一次1B，然后再取一个3B？这个问题从组成原理的角度考虑。32位机器上有4个32位的通用数据寄存器：EAX，EBX，ECX，EDX。每个通用寄存器的低16位又可以单独使用，叫做AX，BX，CX，DX。最后，这四个16位寄存器又可以分成8个独立的8位寄存器：AH、AL等。因此，CPU取数据时或者是一个字节AH或者AL等，或者是两个字节AX，BX等，或者是4个字节EAX，EBX等，而没法一次取三个字节的数据。
  - 如果该int数据的偏移是0x00000002，那么CPU就可以先取一个short，然后再取一个short，两次取值完成一个 int型数据的组合。但是如果偏移是0x00000004，正好是4字节对齐的，那么CPU就可以一次取出这个int类型的数据。所以，为了提高取值速度，一般编译器都会优化数据对齐方式。
- 内存对齐的规则：
  - 数据成员对齐，“偏移”：每个成员的起始位置都能被其中最宽大小整除，每个变量相对于起始位置的偏移，都能被自身大小整除
    - 比如struct中有union{char[13], double}，则union的起始位置必须被8（double的大小）整除
    - 有#pragma pack：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后<u>每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行</u> 
  - 整体对齐，“补齐”：结构体总体大小能被最宽的成员大小整除，不能则在后面补充字节
    - 有#pragma pack：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，<u>对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行</u> 
  - 如果有 `#pragma pack(n)`，且n比按照数据类型得到的对齐方式小，则不按照最大元素的倍数偏移，而是按照n的倍数偏移；union等也按照n的倍数取大小
- struct中包含其他复合结构
  - enum一般占4个字节
  - union中各成员占用的内存从同一地址开始，占自己元素的最小公倍数的大小
    - union{char [13], int}正常是16字节（考虑到是int长度的倍数）；如果有#pragma pack 2，扩充时不是按照4字节的倍数来算，而是按照2的倍数来算。最终得到大小为14字节
  - struct和class在C++中其实是一样的，struct也可以有构造函数，析构函数，成员函数和（private、protected、public）继承。两者的区别在于class默认的成员类型是private，而struct为public。 class默认的继承方式为private，而struct为public。其实核心是struct是数据聚集起来，便于人访问，所以默认的是 public，而class是封装，不让人访问，所以是private。
  - struct或class中定义的<u>成员函数和构造和析构函数不占整体的空间</u>。如果有虚函数的话，会有<u>4个字节的地址存放虚函数表的地址</u>。
  - 类或结构体的<u>静态成员变量不占用结构体或类的空间</u>，也就是说sizeof出来的大小跟静态成员变量的大小无关。在最后补齐字节的时候，也与静态成员变量无关。
    - <u>类或结构体的静态成员变量存储在全局/静态存储区</u>，而类或结构体本身存储在栈上，两者在内存占用上没有关系





#### 堆区和栈区

###### 内存四区：

- ==代码区code==：由操作系统管理，<u>存储二进制代码</u>。<u>可以在栈区存储函数指针，对代码区的代码进行操作</u>。
- ==堆区heap==：<u>由程序员手动分配、释放</u>，程序结束时可能由OS回收。malloc/free，new/delete等。<u>分配方式类似于链表</u>。
- ==栈区stack==：<u>由编译器自动分配释放</u>，<u>存放==函数的参数、局部变量==等</u>
- 数据区，程序结束后由OS释放
  - ==静态全局区static==：存储全局变量和静态变量，C语言按照是否初始化再细分（C++不再分）
    - 凡是有static定义的变量的生命周期就是整个程序的生命周期，直到程序退出，静态变量所占据的内存才会被释放；但依然受作用域的限制
  - ==文字常量区==：存储常量字符串

###### 应用：

- 写程序的时候，用new、malloc分配的变量放在堆中，但返回的指针变量放在栈中。如果在一个子函数中new了一个变量，但函数返回时，没有保存new返回的指针，也没有delete，就会发生内存泄漏。
- 写程序用到最多的是栈内存，<u>每一个临时变量、new返回的指针、递归函数中的变量都存放在栈中</u>。
- 一般来说，堆从低地址向高地址扩充（因为由程序员读写，比较合乎人类常识），而栈从高地址向低地址增长。（听说Windows和Linux是相反的）

###### 堆和栈的区别

- 管理方式：栈由编译器自动管理；堆由程序员手动管理
- 空间大小：堆很大（32位下4G）；栈很小（VC6下1M）
- 碎片问题：堆由new/delete会产生内存空间的不连续，使程序效率降低；栈是先进后出的队列，不可能从中间出栈
- 生长方向：堆向内存地址增大的方向生长；栈向内存地址减小的方向生长
- 分配方式：堆是动态分配的；栈可以静态分配（如编译器自动分配局部变量），也可以由malloc动态分配
- 分配效率：计算机底层有专门的寄存器存放栈的地址，有专门的压栈出栈指令，使得栈的效率高；堆由C/C++函数库提供，分配内存等机制更复杂，效率低

###### 例零（基本概念）：

```c++
int a = 0;	// 全局（静态）区，初始化区
char* p1;	// 全局（静态）区，未初始化区

int main(){
	int b;	// 栈区
	char s[] = "abc";	// 栈区数组，拷贝了常量区的值
	char* p2;	// 栈区
	char* p3 = "123456";	// “123456”在文字常量区，p3在栈区，指向常量区
	
	static int c = 0;	// 全局（静态）区，初始化区
	p1 = (char*)malloc(10 * sizeof(char));	// 在堆区开辟空间，地址被栈区的指针p1指向
	p2 = (char*)malloc(20 * sizeof(char));	// 在堆区开辟空间
	strcpy(p3, "123456");	// “123456”跟之前是同一个对象，在文字常量区
}
```

###### 例一（栈区）：

```c++
char* pMem1(){
	char* p1 = "helloworld";		
    // “helloworld”：全局区，存储文字常量
    // p1：栈区，8字节的指针，存储全局区常量的地址
    return p1;
}
char* pMem2(){
	char* p2 = "helloworld";
    // 全局区不再新开辟空间，p2存储之前的文字常量的地址
	return p2;
}

int main(){
    char* p1 = pMem1();
    // p1：栈区，把函数中p1存的值复制过来
    // 函数调用完毕，栈区上pMem1()函数开辟的空间销毁
    // 函数调用完毕，全局区存的字符串没有销毁
    
    char* p2 = pMem2();
    // p2：栈区，存全局区相同字符串的地址
    
    printf("p1=%s, p1=%p\n", p1, p1);
    printf("p2=%s, p2=%p\n", p2, p2);
    // 输出：可以正常打印字符串
    // 输出：p1和p2指向的字符串、存储的地址都完全相同
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\2.png" alt="70" style="zoom:67%;" />

###### 例二（栈区）：

```c++
char* p_stack(){
    char str[100] = "helloworld";	// 栈区的数组，从常量区把值拷贝到栈区
    return str;
}
int main(){
    char* p = p_stack();		// 指针指向栈区的数组，但该空间在函数执行结束后自动释放了
    print("p=%s", p);
    // 输出：不能正常打印字符串
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\3.png" alt="70" style="zoom:67%;" />



两个例子都是在全局区上开辟空间存储文字常量。

- 例一使<u>用指针（栈区）存储文字常量区的地址</u>，并返回给main函数（栈区），因此在函数中的指针销毁后依然能正常读取全局区的常量。
- 例二<u>使用数组（栈区）存储文字常量的值</u>，将数组的地址返回给main函数，但函数结束后栈区的数组被释放了，因此main函数无法获得栈区存储的字符串。
- 问题的核心：<u>函数结束后，栈区会自动释放，全局区不会自动释放</u>。

因此，在栈区开辟数组有风险。类似操作可以<u>转移到堆上</u>，因为堆区是由程序员手动管理。

###### 例三（堆区）：

```c++
char* p_heap(){
    char* temp = (char*) malloc(100);	// 在堆上开辟内存空间
    strcpy(temp, "helloworld");
    return temp;
}
int main(){
    char* p = p_heap();		// p_heap函数的栈区空间被回收，但栈区的p存储了堆区的地址
    printf("%s\n", p);
    free(p);	// 把p跟堆区的映射解除。不会清空堆区数据，而是告诉OS这部分内存可用
    return 0;
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\4.png" alt="70" style="zoom:67%;" />

###### 例四（结构体）：

```c++
struct MyStruct{
    char c[100];
    int i;
}

// 静态结构体数组，在栈上分配空间
MyStruct m1[3] = { {"hello", 10}, {"world", 10}, {"!", 3} };

// 动态结构体数组，在堆上分配空间，在栈上声明指针指向这个空间
MyStruct* m2 = (MyStruct*)malloc(3 * sizeof(MyStruct));
for(i...){
    strcpy(m2[i].c, "...");
    m2[i].i = ...;
}
free(m2);
```





#### 内存分布

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\5.png" alt="70" style="zoom:67%;" />





#### 虚函数

C++中的虚函数的作用主要是实现多态。<u>用父类的指针指向子类的实例，然后通过父类的指针调用子类的成员函数</u>。

```c++
// 虚函数
class A{
public:
	virtual void foo(){
        cout<<"A::foo() is called"<<endl;
    }   
};
class B:public A{
public:
	void foo(){
        cout<<"B::foo() is called"<<endl;
    }   
};
int main(){
    A* a = new B();
    a->foo();		// 在这里，使用父类A的指针指向子类B的对象，调用子类B的函数
    // 输出结果：B::foo() is called
    return 0;
}
```

###### 纯虚函数

纯虚函数在基类中声明但不定义，要求任何派生类定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 `=0`。

```c++
virtua void funciton() = 0;
```

纯虚函数引入的原因是：

- 为了方便使用多态特性，需要在基类中定义虚函数。

- 很多情况下，基类本身生成对象是不合理的。例如动物可以派生出猫狗类，但动物类本身生成对象不合常理。

<u>含有纯虚函数的类称为抽象类，它不能生成对象</u>。用户不能创建类的实例，只能创建它的派生类的实例。

纯虚函数让所有派生类的对象都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个默认实现。”你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它。“

###### 虚函数，纯虚函数

<u>定义一个函数为虚函数，不代表函数不被实现</u>（如上面的代码实现了foo()），而是为了允许使用父类的指针来调用子类的这个函数。

<u>定义一个函数为纯虚函数，才代表函数没有被实现</u>，是为了实现一个接口，起到规范的作用，使继承这个类的程序员必须实现这个函数。

###### 抽象类

- 定义：带有纯虚函数的类称为抽象类
- 作用：将操作作为接口，组织在一个继承层次结构中，为派生类提供一个公共的根，要求派生类必须实现在基类中的接口
- <u>抽象类是不能定义对象的</u> 
- 使用时注意：抽象类只能作为基类使用。如果子类没有重新定义（全部的）纯虚函数，那这个子类仍然是一个抽象类，依然不能定义对象

###### 实现注意

- 虚函数是C++中实现多态的机制，核心理念就是通过基类访问派生类的函数
- 在有动态分配堆内存时，析构函数必须是虚函数，但没必要是纯虚函数
- 析构函数应当是虚函数，因此父类指针指向子类对象，调用子类析构函数时，会自动调用基类析构函数
  - 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数
  - 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数

###### 构造函数，析构函数

- ==构造函数不能是虚函数==：<u>虚函数的调用需要虚函数表指针vptr，该指针存放在==对象的内存空间==中</u>。若构造函数是虚函数，那么由于对象未创建，没有内存空间，无法获得虚函数表地址用来调用虚函数——构造函数
- ==基类的析构函数最好是虚函数==：虚函数目的是用基类指针调用子类方法
  - 如果基类的析构函数不是虚函数，会调用基类的析构函数，只释放了派生类中的基类部分，造成内存泄漏
  - 如果基类的析构函数是虚函数，会先调用派生类的析构函数，然后调用基类的析构函数

```c++
class A{}
class B:public A{}

// 如果A的析构函数不是虚函数，delete p只调用A的析构函数
// 如果A的析构函数是虚函数，delete p先调用B的析构函数、再调用A的析构函数
A* p = new B;
delete p;

// p是B的对象，也是先调用B的析构函数、再调用A的析构函数
B* p = new B;
delete p;
```

###### vptr

若类中包含虚函数，则编译器会在类实例化对象时，在对象中加入vptr指针，它指向一个虚函数表。

<u>子类和父类对象分别指向自己类的虚函数表</u>，所以使用父类指针调用类的虚函数时，会根据实际的对象是子类对象还是父类对象，来实现虚函数的调用。





#### 右值引用（C++ 11）

右值引用：以引用传递（而非值传递）的方式使用C++右值。

###### 左值，右值

- 左值：lvalue（**locator** value），意为<u>存储在内存中、有明确存储地址（可寻址）的数据</u>
- 右值：rvalue（**read** value），意为<u>可提供数据值的数据，不一定可寻址（如存储与寄存器中的数据）</u>

判断表达式是左值还是右值的方法：

- ==可位于=左侧的表达式是左值，只能位于=右侧的表达式是右值== 
  - `int a = 5;` 5是右值，a是左值
  - C++的左值可作右值。`a = b; `
- ==有名称、可获取到存储地址的表达式是左值；反之是右值== 
  - &a &b可以获得地址，a和b是左值
  - 5是字面常量，没有名称、无法获取存储地址（字面常量通常存储于寄存器，或和代码存储在一起），因此是右值

###### 右值引用

在C++ 98/03，不支持为右值创建非常量的左值引用。（常量左值引用可以操作右值）

```c++
int num = 10;
int& b = num;	// 正确，为num创建左值引用
int& c = 10;	// 错误，无法创建右值 10 的引用

const int& bb = num;	// 正确
const int& cc = 10;		// 正确
```

右值往往没有名称，开发中我们可能需要对右值进行修改，左值引用是不行的。因此，C++ 11引入了右值引用。

- 和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化
- 右值引用可以对右值进行修改
- 语法上支持常量右值引用，但无实际用处

```c++
int num = 10;

int&& a = num;	// 错误，右值引用不能初始化为左值
int&& a = 10;	// 创建右值引用

a = 100;	// 修改右值

const int&& aa = 10;	// 常量右值引用，没有实际用处
```

###### 应用

右值引用主要是用在两处：<u>移动语义、完美转发</u>。

###### std::move()

utility中提供一个函数：`std::move`，功能是将一个左值强制转换成右值引用。避免复制，而是转移资源控制权。

- https://www.zhihu.com/question/467449795/answer/1961099671
- std::move进行了一种人工的转化，在转化之后，其返回了一个右值。通过使用这个右值，我们可以调用任何重载了使用右值作为形参的版本的函数。这样的函数一般利用了“==避免复制，而是转移资源控制权==”这一理念，从而高效的转移被分配的内存，<u>避免了多次重分配内存带来的性能降低</u>。其代价是，我们必须有意识地遵守一个基本规定，“右值是不可使用的”。<u>在使用了std::move转化出的右值之后，对于原始的对象我们不要对其进行任何的访问、修改，静待它被析构即可</u>。

在unique_ptr的移动中用到。





#### 智能指针（C++ 11）

###### 总览

智能指针封装了一个普通指针，主要解决指针申请空间但不释放，造成内存泄漏的问题。

- auto_ptr 是C++ 98的智能指针，由于可以直接赋值导致右边的指针的所有权被剥夺，可能产生内存泄漏
- unique_ptr：实现“独占”的概念，同一时间只有一个指针指向该对象
  - 不能被复制构造，或使用赋值运算符剥夺控制权
  - 当程序试图把一个unique_ptr赋值给另一个时，如果它是一个临时右值则可以赋值，如果是一个存在一段时间的变量就不能复制
  - 可以使用std::move()进行控制权的转让，转让后右边的指针变为悬空指针

- shared_ptr：实现“共享”的概念，多个指针同时指向一个对象
  - 内置一个计数器use_count，标记有多少个智能指针指向对象，如果计数器为0则析构本智能指针
  - 可能出现死锁的情况，两个shared_ptr互相引用，计数器都是2，退出函数时变为1，都不析构
  - 除了通过new构造，还可以传入auto_ptr，unique_ptr，weak_ptr来构造
- weak_ptr
  - 主要为了解决上述死锁问题，weak_ptr不计数，可以让shared_ptr正常析构
  - 是一种弱引用，无法访问对象的内部进行操作
  - 可以跟shared_ptr相互转换



智能指针的作用是管理一个指针。存在以下情况：申请的空间在函数结束时忘记释放，带来空悬指针问题、造成内存泄漏。

<u>智能指针的作用原理：智能指针本身是一个类，封装了一个普通指针，主要解决指针忘记释放的问题。超出类的作用域时（函数结束时），类自动调用析构函数，析构函数自动释放资源。</u>

智能指针用于动态分配内存，设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。常在多线程程序中运用。

###### 1.unique_ptr

实现独占的概念，==无法进行拷贝构造和拷贝赋值，可以进行移动构造和移动赋值==。

`unique_ptr`拥有对持有对象的唯一所有权。即<u>同一时间两个`unique_ptr`不能同时指向同一个对象</u>。

- `unique_ptr`不能被复制到另一个`unique_ptr` 
- `unique_ptr`所持有的对象只能通过转义语义将所有权转移到另一个`unique_ptr` 

```c++
std::unique_ptr<A> a1(new A());
std::unique_ptr<A> a2 = a1;	// 错误
std::unique_ptr<A> a3 = std::move(a1);	// 可以，所有权转移后，a1不再拥有任何指针
```

unique_ptr拥有的方法：

- get()：获取其保存的原生指针，尽量不要用
- bool()：判断是否拥有指针
- release()：释放所管理指针的所有权，返回原生指针，并不销毁原生指针
- reset()：释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针

```c++
std::unique_ptr<A> a1(new A());
A* origin_a = a1.get(); 	// 尽量不要暴露原生指针
if(a1){
    // a1 拥有指针
}

std::unique_ptr<A> a2(a1.release());	// 常见用法，转义拥有权
a2.reset(new A());		// 释放、销毁原有对象，持有一个新对象
a2.reset();			// 释放、销毁原有对象，等同于下面写法
a2 = nullptr;		// 释放、销毁原有对象
```

###### 2.shared_ptr

与`unique_ptr`的唯一所有权所不同的是，`shared_ptr` 实现共享拥有的概念。也就是说<u>多个`shared_ptr`可以拥有同一个原生指针的所有权</u>。

`shared_ptr` 通过引用计数的方式管理指针，当引用计数为 0 时会销毁拥有的原生对象。

###### 3.weak_ptr

`weak_ptr` 解决`shared_ptr` 相互引用时，两个指针的引用计数不清零、导致死锁的问题。

`weak_ptr` 是对对象的一种弱引用

- 是一个弱指针，本身不能直接调用原生指针的方法。如果想要使用原生指针的方法，需要将其先转换为一个`shared_ptr`
- 可以绑定到 `shared_ptr` ，但不会增加对象的引用计数

###### 实际使用

- `unique_ptr`独占对象的所有权，由于没有引用计数，因此性能较好
- `shared_ptr`共享对象的所有权，但性能略差
- `weak_ptr`配合`shared_ptr`，解决循环引用的问题

###### 实现shared_ptr

```c++
template <class T>
class SmartPtr{
private:
    T* ptr;
    int* use_count;
public:
    SmartPtr(T* p);
    ~SmartPtr();
    SmartPtr(const SmartPtr<T>& orig);
    SmartPtr<T>& operator=(const SmartPtr<T>& rhs);
}

template<class T>
SmartPtr<T>::SmartPtr(T* p):ptr(p){
    try{
        use_count = new int(1);
    }
    catch(...){
        delete ptr;
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
        cout << "Allocate memory for use_count fails." << endl;
        exit(1);
    }
    cout << "Constructor is called!" << endl;
}

template<class T>
SmartPtr<T>::SmartPtr(const SmartPtr<T>& orig){
    ptr = orig.ptr;
    use_count = orig.use_count;
    ++(*use_count);
    cout << "Copy constructor is called!" << endl;
}

template<class T>
SmartPtr<T>& SmartPtr<T>::operator=(const SmartPtr<T>& rhs){
    ++(*rhs.use_count);
    if(--(*this.use_count) == 0){
        delete ptr;
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
        cout << "Left side object is deleted!" << endl;
    }
    ptr = rhs.ptr;
    use_count = rhs.use_count;
    
    cout << "Assignment operator overloaded is called!" << endl;
    return *this;
}

template<class T>
SmartPtr<T>::~SmartPtr(){
    if(--*(use_count) == 0){
        delete ptr;
        ptr = nullptr;
        delete use_count;
        use_count = nullptr;
    }
}
```





#### 四种智能指针再理解

###### 1. auto_ptr

auto_ptr采用所有权模式：

```c++
auto_ptr<string> p1(new string("HelloWorld!"));
auto_ptr<string> p2;
p2 = p1;	// auto_ptr不会报错
```

<u>p2剥夺了p1的所有权，但当程序访问p1时会报错</u>。auto_ptr存在潜在的内存崩溃问题，在C++11中已被弃用。



###### 2. unique_ptr

unique_ptr 替换 auto_ptr，实现独占的概念，保证同一时间只有一个智能指针可以指向该对象，对于避免资源泄露（比如new创建对象后忘记delete）特别有用。

unique_ptr采用所有权模式：

```c++
unique_ptr<string> p1(new string("HelloWorld!"));
unique_ptr<string> p2;
p2 = p1;	// 此时报错
```

在直接转移所有权时，编译器报错，避免了p1不再指向有效数据的不安全问题。



另外，当程序试图将一个 unique_ptr 赋值给另一个时 ，<u>如果源 unique_ptr 是一个临时右值，编译器就允许；如果源 unique_ptr 将存在一段时间，编译器就禁止这么做</u>。

```c++
unique_ptr<string> p1(new string("HelloWorld!"));
unique_ptr<string> p2;
p2 = p1;	// 此时报错，p1作为对象存在内存

unique_ptr<string> p3;
p3 = unique_ptr<string>(new string("HelloWorld! rvalue"));	// 不报错，用临时右值给p3赋值
```

- `p2 = p1;` 留下悬挂指针p1，编译器禁止这样做
- `p3 = unique_ptr<string>(new string("HelloWorld! rvalue"));` 不会留下悬挂指针，因为调用unique_ptr 的构造函数，创建临时变量、转让所有权给p3然后被销毁



执行类似 `p2 = p1` 的操作需要使用==移动语义==：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);	// ps1的控制权转移给ps2，ps1悬空
ps1 = demo("world");	// 通过赋新值，重用ps1
```



###### 3. shared_ptr

shared_ptr实现共享概念，多个智能指针指向相同对象，该对象和相关资源会在”最后一个引用被销毁“时释放。

- 使用==计数机制==来表明资源被几个指针共享，通过成员函数 `use_count()` 查看资源的所有者个数
  - 当调用 `release()` 时，当前指针释放资源所有权，计数减一
  - 计数为0时，资源被释放
- 除了使用new来构造，还可通过传入 auto_ptr、unique_ptr、weak_ptr 来构造



###### 4. weak_ptr

weak_ptr 指向一个 shared_ptr 管理的对象，但不进行内存管理。

- shared_ptr 作为强引用，进行对象的内存管理；<u>weak_ptr 是对象的弱引用</u>，仅提供对象的一个访问手段
  - <u>不能通过 weak_ptr 直接访问对象的方法</u>，需要转换成 shared_ptr
- weak_ptr 只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造， 可以跟 shared_ptr 相互转换
  - shared_ptr 直接赋值给 weak_ptr
  - weak_ptr 通过 `lock()` 来获得 shared_ptr
- weak_ptr 的目的是为了==解决 shared_ptr 互相引用而出现的死锁问题==（计数器永不为0，资源永不释放）

```c++
class A{
public:
    shared_ptr<B> pa_;
    ~A(){ cout<<"delete A"<<endl; }
}

class B{
public:
    shared_ptr<A> pa_;
    ~B(){ cout<<"delete B"<<endl; }
}

void fun(){
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    
    // 两个 shared_ptr 相互引用
    pb->pa_ = pa;
    pa->pb_ = pb;
    
    // 发现出现死锁，计数都是2
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}


int main(){
    fun();
    return 0;
}
```

此时两个资源的引用计数都为2。跳出函数时各自-1还是不为0，导致资源未释放（==没到0，A、B的析构函数没被调用==）。

把其一改为 weak_ptr，则问题解决。如果把 A 中的智能指针改为 weak_ptr：

- <u>资源B的引用计数为1（A对B是弱引用，不计数），pb退出函数时B的计数为0，B析构释放</u> 
- <u>资源A的引用计数为2（B对A是强引用），B释放同时，A的计数-1，析构再-1，A的计数为0，A释放</u> 





#### 数组指针、指针数组

https://www.cnblogs.com/mq0036/p/3382732.html

- 指针数组：<u>存储指针的数组</u>。是一个==数组==，数组的元素都是指针。
  - 长度：指针长度（系统字长） * 数组元素个数
  - `int* p1[10]` ：p1是数组，存的是 int* 地址类型，也就是指针组成的数组

- 数组指针：<u>指向数组的指针</u>。是一个==指针==，指向一个数组。
  - 长度：指针长度（系统字长）
  -  `int (*p2)[10]` ：p2是指针，指向 int[10] 的数组

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\1.png" alt="70" style="zoom:67%;" />

###### 使用

```c++
int a[3][4];
int (*p)[4]; 	// 定义数组指针，每个指针指向 int[4] 的数组
p = a;			// 将a的首地址赋给p，p指向
p++;			// 现在p指向行a[1][]
```





#### a和&a

```c++
int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int* p1 = a;
int (*p2)[10] = &a;
```

- a：
  - a是数组名，也是数组的首元素地址。
  - 相当于指针数组，可以用来遍历数组
  - (a+1)表示地址a加上一个int类型的大小，如果`a = 0x01`，则`(a+1) = 0x05`，`*(a+1) = a[1]`。
- &a：
  - &a是数组的指针（数组指针），类型为 int(*)[10]
  - 把&a赋值给p，(&a+1)=p+1 指向整个数组结束后的下一个地址





#### C和C++的区别

- C是面向过程语言，C++是面向对象语言
- C使用==malloc/free库函数==管理堆内存，C++使用==new/delete运算符==
- C++引入==引用==的概念
- C++引入==类==的概念
- C++引入==函数重载==的特性
- static
  - C的 static 用来修饰局部静态变量、外部静态变量
  - C++引入类，因此 static 还可修饰静态成员变量、静态成员函数
  - 编程时，static 具有记忆性、全局性的特点，可以使在<u>不同时期调用的函数</u>进行通信，而C++的静态成员变量则可以在<u>多个对象实例之间</u>进行通信、传递信息





#### delete 和 free 的区别

- malloc/free 是==库函数==，new/delete 是==运算符==

- 析构函数不负责释放自己，只负责释放自己分配的子对象
- ==free只释放对象本身的内存，delete要调用析构函数==。析构函数负责释放实现该对象的程序员自己觉得需要释放的其它资源。——这些资源的信息记录在对象本身，所以<u>需要先释放这些资源之后才能释放对象本身的内存</u> 





#### static

###### 总览

- 全局静态变量
  - 内存：静态存储区，整个程序运行期间一直存在
  - 初始化：未经初始化就默认初始化为0
  - 作用域：全局静态变量在声明它的文件之外不可见，作用域从定义之处开始、到文件结尾
- 局部静态变量
  - 内存：静态存储区
  - 初始化：默认0
  - 作用域：局部作用域。离开作用域时，没有被销毁，再次被调用时其值保持不变
- 静态函数
  - 函数的声明和定义在默认情况下都是extern的，但==静态函数只在声明它的文件中可见，不能被其他文件所用==
  - 对于被static修饰的普通函数，其只能在定义它的源文件中使用，不能在其他源文件中被引用
    - 在多个 .cpp 文件中的同名函数会引起冲突
    - 使用static修饰，那么这个函数只可在本.cpp中使用，不会同其他.cpp中的同名函数起冲突
  - warnings：
    - 不要在.h中声明static的全局函数；不要在.cpp中声明非static的全局函数
    - 如果要在多个.cpp中复用该函数，就声明到.h中，否则在.cpp中加上static修饰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
- 类的静态成员变量
  - 类的静态成员可以实现多个对象之间的数据共享
  - 存储在静态常量区，每个对象持有一个复制
  - 可以通过作用域访问，不能通过普通成员函数访问
- 类的静态成员函数
  - 类的普通函数要传入this指针，静态成员函数不用（因为不存在类中，而是存在静态区）
  - 可以通过作用于访问
  - 静态成员函数主要操作类的静态成员变量，不能使用类的非静态对象



static定义一个静态变量，使变量在==静态存储区==分配内存。<u>函数内的static变量会在程序执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁</u>。在此期间，函数执行结束后也不会对它有影响（不受函数生命周期的限制）。<u>生命周期不受影响，但作用域依然有影响</u>。

- static修饰局部变量，生命周期为函数的生命周期，作用域依然为局部作用域
- static修饰全局变量，变量在整个文件中可见
  - 当一个全局变量在.h头文件中，被多个.cpp文件引用时，编译不会出错，但会导致“符号被多重定义”，需加上static，使其变为==内部链接==，变成多个同名不同义的定义。
- static修饰函数，在声明该函数的整个文件中可见，文件外不可见，从而可以在多人协作中避免同名函数冲突
- static修饰类的成员变量：==静态成员变量==。所有对象都只维持一分拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问`Student::num_toal` 
  - <u>静态成员变量不占用对象的内存，也是在静态全局区存放</u>。因此可以直接访问

- static修饰类的成员函数：==静态成员函数==。普通==静态成员函数没有 this 指针==，不知道指向哪个对象，无法访问对象的成员变量，也就是说<u>静态成员函数不能访问普通成员变量，只能访问静态成员变量</u>
  - 在C++中调用类的成员函数，会传递一个this指针，<u>将类的实例化对象的首地址传递给成员函数</u>，函数操作会根据对象首地址计算其成员变量的地址，然后进行操作。然而静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到this指针。这使普通函数访问静态成员变量

###### 静态成员变量

```c++
class Student{
public:
    Student(char* name, int age, float score);
    void show();
public:
	static int num_total;	// 静态成员变量，多个对象共享
private:
    char* m_name;
    int m_age;
    float m_score;
}

int Student::num_total = 0;	// 静态成员变量初始化

// 实现构造函数
Student::Student(char* name, int age, float score):m_name(name), m_age(age), m_score(score){
    num_total += 1;
}

void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"（当前共有"<<m_total<<"名学生）"<<endl;
}

int main(){
    
    // 通过类访问静态成员变量
    Student::num_total = 1;
    
    // 通过对象访问静态成员变量
    Student stu("johnsmith", 19, 83);
    stu.num_total = 2;
    
    // 通过对象指针访问静态成员变量
    Student* pStu = new Student("lihua", 18, 84);
    pStu->num_total =20;
    
    // 创建匿名对象
    (new Student("小明", 15, 90)) -> show();		// 打印第4名
    (new Student("李磊", 16, 80)) -> show();		// 打印第5名
    (new Student("张华", 16, 99)) -> show();		// 打印第6名
    (new Student("王康", 14, 60)) -> show();		// 打印第7名
    // 使用匿名对象无法回收内存，会导致内存泄露，在大型程序中不建议使用。

    return 0;
}
```

###### 静态成员函数

```c++
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:
    // 声明静态成员函数
    static int getTotal();
    static float getPoints();
private:
    // 静态成员变量
    static int m_total;  //总人数
    static float m_points;  //总成绩
private:
    char *m_name;
    int m_age;
    float m_score;
};

int Student::m_total = 0;
float Student::m_points = 0.0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;
    m_points += score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

//定义静态成员函数，访问静态成员变量
int Student::getTotal(){
    return m_total;
}
float Student::getPoints(){
    return m_points;
}

int main(){
    (new Student("李明", 15, 90.6)) -> show();
    (new Student("王磊", 16, 80.5)) -> show();
    (new Student("刘华", 16, 99.0)) -> show();
    (new Student("张康", 14, 60.8)) -> show();
    int total = Student::getTotal();
    float points = Student::getPoints();
    cout<<"当前共有"<<total<<"名学生，总成绩是"<<points<<"，平均分是"<<points/total<<endl;
    return 0;
}
```





#### const

const用来定义==值不能改变的变量==，<u>const变量一旦创建就不能再变化，所以const对象必须初始化</u>。

###### 指针常量、常量指针

从右向左看，\*和const按顺序读就是类型的名称*（翻译过来的名称我好像搞反了，但看代码知道意思即可）*。

或者从右向左，把*读成 a pointer to ：

- `int* const p;` p is a const pointer to int，指针是常量
- `int const* p;` p is a pointer to const int，指针指向的是常量
- `const int* p;` p is a pointer to int const，指针指向的是常量，跟上面相同
- `const int* const p;` p is a const pointer to int const，都是常量
- 指向的是常量：普通指针，指向的内容是常量。不能通过指针修改内容，可以修改指针指向的地址。
  - 也称底层const
- 指针是常量：不能修改指向的地址，可以通过指针修改内容。
  - 也称顶层const
- 常量指针常量：都不能。

```c++
const int a = 1, b = 2, c= 3;

// 指向的是常量，可以修改指针指向的地址，不能通过指针修改内容。修改内容可以通过指向别的地址。
const int* p1 = &a;

int const* p2 = &a;

p1 = &b;  // 正确
p2 = &b;  // 正确

p1 = &c;  // 正确
*p1 = 100;  // 错误
p1 = p2;  // 正确



// 指针是常量，可以通过指针修改内容，但不能指向其他地址。
int* const p3 = &a;
p3 = &b;  // 错误
*p3 = 100;  // 正确


// 常量指针常量，不允许修改地址，也不允许修改内容
const int* const p = &a;
*p = 100;  // 错误
p = p2;  // 错误
```

###### const 形参

- `func(const int a){}` 该形参在函数里不能被更改
- <u>常量指针、指针常量的最大用途就是作为函数的形参，保证实参在被调用函数中不被改变</u> 

###### const 修饰类成员函数

- 若指定类的成员函数为const类型，则表明是一个常函数，<u>不能改变类的成员变量</u>。

- 对于类的成员函数，有时必须指定其返回值为const类型，使其返回值不为“左值”





#### #define 和 const

- #define 宏在==<u>预处理阶段</u>==展开，在代码中进行<u>字符串替换</u>（不进行安全检查），不会分配内存，存储于<u>代码段</u>中
- const 常量在==<u>编译阶段</u>==进行<u>类型检查</u>，存储在<u>数据段</u>中的常量区
- #define 不受定义域限制，const 只在定义域内有效





#### static 和 const

- static定义静态变量或方法，强调<u>在内存中只有一份</u>，且可以被共享
  - 函数体内的static变量的作用域为函数体，<u>内存只被分配一次、且函数执行完后不销毁</u>，因此其值在下次调用时仍维持上次的值
  - 模块内的static静态变量和函数可以被同模块内的函数访问，不能被模块外的函数访问
  - 类的static成员变量：被整个类拥有，类的所有对象有一份拷贝，可以不通过对象直接访问
  - 类的static成员函数：主要为了访问类的静态成员变量，不接收this指针，不能访问非静态成员，可以直接调用
- const定义常量，强调<u>不能被改变</u>
  - 阻止一个变量被改变
  - 可以声明常量指针和指针常量
  - 修饰形参表明它是一个输入参数，在函数内不能改变它的值
  - 类的const成员函数：它是一个常函数，不能改变类的成员变量
  - 对于类的成员函数，有时必须指定其返回值为const类型，使其返回值不为“左值”





#### 内联函数

使用inline内联函数，实现频繁调用的短小函数。

优点：

- 在内联函数被调用的地方进行代码展开，==省区函数调用的时间==，提高程序效率
- 相比于宏函数，内联函数在代码展开时，==编译器会进行语法安全检查==

缺点：

- 代码膨胀，更多开销
- 如果内联函数内，代码块的执行时间比调用函数时间长得多，那么效率并没有提升很多
  - 因此适用于短小、频繁调用的函数
- 如果修改内联函数，那么所有调用该函数的代码文件都需重新编译
  - <u>内联声明只是建议，是否内联由编译器决定</u>，所以实际上并不可控





#### 悬挂指针和野指针

- <u>悬挂指针：指针所指向的对象被释放，但指针没有改变，依然指向已被回收的内存地址</u> 
- <u>野指针：未经初始化、不指向对象的指针</u> 

如何避免野指针

- 指针没有被初始化
  - 指针声明时初始化。可以指向具体地址，也可以指向nullptr
- 指针p被free或delete后，没有指向对象、也没有置为nullptr
  - 指针指向的内存被释放后，指针指向nullptr

- 指针操作超过了变量的作用范围
  - 在变量作用域结束前，释放掉变量的地址、指针指向nullptr





#### 静态链接，动态链接

- 静态链接：==编译时链接==。在编译链接时，==直接将需要执行的代码拷贝到调用处==
  - 优点：程序发布时不需要依赖库，可以独立执行
  - 缺点：程序体积相对大；静态库更新后，可执行文件需要重新链接
- 动态链接：==运行时链接==。在编译时不直接拷贝执行代码，而是记录并传给OS，在程序运行到指定代码时，<u>在共享执行内存中寻找已经加载的动态库可执行代码</u>，实现运行时链接
  - 优点：多个程序可共享一个动态库
    - 动态链接库位于内存的堆栈中间部分
  - 缺点：由于在运行时加载，可能影响程序的前期执行性能





#### 变量的声明和定义，extern

###### extern

- 声明：<u>不分配地址空间</u> 
  - <u>一个变量可以在多个地方声明</u>，extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分进行定义
- 定义：<u>分配变量的地址和存储空间</u> 
  - <u>一个变量只能在一个地方定义</u> 

```c++
int main(){
    extern int a;	// 声明 a 是一个外部变量
}

int a;	// 定义 a，为 a 分配内存空间
```

###### extern "C"

作用是为了实现C++代码调用其他C语言代码。加上 extern "C" 后，会指示编译器按C语言的方式编译这部分代码。主要使用场景：

- C++代码调用C语言代码
- 在C++的头文件中使用
- 在多人协作中，有擅长C语言的人





#### 条件编译

条件编译语句 `#ifdef`、`#endif`、`#else`、`#ifndef` 等

- 将某程序功能模块包括进去，以向特定用户提供该功能，在不需要时用户可将其屏蔽

```c++
#ifdef MATH
#include "math.c"
#endif

#ifdef DEBUG
printf("debug message");
#endif
```

直接使用if语句也可以达到要求，但所有语句都进行编译。<u>使用条件编译，可以减少被编译的语句</u>，从而减少目标程序的长度、减少运行时间。





#### 判断 0

```c++
// 整型
if(n == 0);
if(n != 0);

// 布尔类型
if(b);
if(!b);

// 浮点型，由于二进制存储，小数部位不可避免地有误差
const float EPSINON = 1e-6
if(fabs(f) <= EPSINON);
if(fabs(f) > EPSINON);

// 指针
if(p == nullptr);
if(p != nullptr);
```





#### 深拷贝，浅拷贝

深拷贝和浅拷贝主要针对对象的属性是对象（引用类型）

###### 数据类型的存储

- 基本数据类型：直接存在栈中

- 引用数据类型：在栈中存储地址，真实的数据可能存在堆中

###### 赋值（浅拷贝）时的内存变化

- 当把一个对象赋值给新的变量是，<u>赋值的是对象存在栈中的地址，而不是堆中的数据</u>

- 也就是说，两个对象指向同一个存储空间，无论哪个对象发生改变，都是改变的存储空间的内容，两个对象是联动的

###### 基本类型和引用类型作为函数参数的区别

传参时，<u>栈上开辟空间存储函数的参数</u>，并把实参拷贝到空间中

- <u>对于基本类型，拷贝的是值，函数内修改栈上参数的值</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\6.png" alt="70" style="zoom:67%;" />

- <u>对于引用类型，拷贝的是地址，因此函数会对堆中相应地址的元素直接进行修改</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\7.png" alt="70" style="zoom:67%;" />

###### 浅拷贝和深拷贝

默认拷贝构造函数可以完成对象的数据成员简单的复制,这也称为浅拷贝。对象的数据资源是由指针指向的堆时,默认的拷贝构造函数只是将指针复制。

- 结构体可以直接赋值，但当结构体中含有指针“成员”时需要小心，如果进行浅拷贝，不同对象的指针成员都指向同一个位置，当其中一个指针释放内存后，其他指针将悬空，造成内存泄漏





#### sizeof 和 strlen

- sizeof是==操作符也是关键字==，参数可以是数据的类型 `sizeof(int*);`，计算参数在内存中的大小（占多少Byte）
- strlen是==库函数==，参数只能是以 \0 结尾的字符串，计算字符串的长度而不是内存大小
- 编译器在==编译==时就计算出了sizeof的结果，而strlen函数必须在==运行==时才计算出结果
- 数组作为sizeof参数时不退化，作strlen的参数则退化成指针





#### strcpy，sprintf 和 memcpy

- strcpy<u>实现字符串变量间的拷贝</u>；的两个操作对象均为字符串；执行效率中等
- sprintf<u>实现其他数据类型到字符串的转化</u>；源操作对象可以是多种数据类型，目的操作对象是字符串；执行效率最差
- memcpy<u>实现内存块间的拷贝</u>；两个操作对象是任意可操作的内存地址，不局限于数据类型；执行效率最高





#### volatile

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<u>直接从变量在内存的地址中读取数据，而不是去寄存器读取它的备份</u>

volatile在PC软件的多线程中，主要用于<u>修饰临界变量</u>。常修饰：

- 状态寄存器一类的并行设备硬件寄存器
- 一个中断服务子程序会访问到的非自动变量
- 多线程间被几个任务共享的变量

一个参数可以既是const又是volatile吗？

- 可以，同时修饰表示：<u>变量在程序内部是只读的（const），只在程序外部条件变化下改变</u> 
- 编译器不会优化这个变量，每次使用时需要从内存读取这个变量的值，而不是去寄存器读取它的备份
- 这里的const只是不允许程序中的代码改变某一变量，在编译期发挥作用。const并不实际地禁止某段内存的读写特性





#### 全局变量和局部变量

- 全局变量是整个程序都可访问的变量，生命周期从程序运行到结束，在程序结束时所占的内存空间被释放
- 局部变量存在于模块（子程序、函数）中，只有所在模块可以访问，模块结束后局部变量所占据的内存被释放
- OS和编译器通过变量存在内存的位置，知道这是局部变量还是全局变量
  - 局部变量存放于堆栈
  - 全局变量存放于全局（静态）数据段，并在重新开始运行的时候被加载





#### 函数指针

- `int* f(int i, int j);` 这是普通函数，返回值是指针 `int*` 
- `int (*p)(int i, int j);` 这是指向函数的指针（函数指针）

函数具有可赋值给指针的物理内存地址

- 一个函数名就是一个指针，指向函数的代码
- 一个函数的地址是该函数的进入点，也是调用函数的地址

函数的调用可以通过函数名，也可以通过指向函数的指针进行调用。函数指针还允许将函数作为变元，传递给其他函数。

定义、赋值、使用语法不拘一格：

```c++
int get_max(int i, int j){}
int get_min(int i, int j){}

int (*p)(int, int);		// 定义
int (*p)(int i, int j);	// 定义

p = get_max;	// 赋值
p = &get_max;	// 赋值

p(a, b);	// 调用
(*p)(a, b);	// 调用
```

###### 例一：

```c++
int get_max(int i, int j){ return i>j?i:j; }
int get_min(int i, int j){ return i<j?i:j; }

int compare(int i, int j, bool flag){   
    // 定义函数指针，根据flag，决定指向哪个函数、并进行调用
    int (*p)(int ,int);
    
    if(flag) p = get_max;
    else p = get_min;
    
    return p(i, j);
}

int main(){
    int i=5, j=10, ans;
    
    ans = compare(i, j, true);
    printf("the max is %d\n", ans);
    
    ans = compare(i, j, false);
    printf("the min is %d\n", ans);
    
    return 0;
}
```

###### 例二（将函数作为变元，传递给其他函数）：

```c++
void check(char* a, char* b, int (*cmp)(const char*, const char*)){
    if((*cmp)(a, b) == 0) printf("equal.\n");
    else printf("not equal.\n");
}

int main(){
    char s1[100], s2[90];
    printf("enter two values or two strings: \n");
    gets(s1);
    gets(s2);
    
    int (*p)(const char*, const char*);
    p = strcmp;		// 用库函数给函数指针赋值
    
    check(s1, s2, p);
    
    return 0;
}
```

###### 例三：

```c++
void compvalues(const char* a, const char* b){
    if(atoi(a) == atoi(b)) return 0;
    else return 1;
}

// check接收函数指针作为参数
void check(char* a, char* b, int (*cmp)(const char*, const char*)){
    if((*cmp)(a, b) == 0)	printf("equal.\n");
    else printf("not equal.\n");
}

int main(){
    char s1[100], s2[90];
    printf("enter two values or two strings: \n");
    gets(s1);
    gets(s2);
    
    // 根据输入的数组类型，把函数指针传给check，调用不同的函数
    if(isdigit(*s1)){
        printf("testing values for equality... \n");
        check(s1, s2, compvalues);
    }
    else{
        printf("testing strings for equality... \n");
        check(s1, s2, strcmp);
    }
    return 0;
}
```





#### 指针和引用的区别

- ==指针是一个对象==，有单独的空间，而==引用只是别名==
- 使用sizeof查看，一个指针的大小是固定的，而引用的大小是被引用对象的大小
- 作为参数传递时，<u>指针需要被解引用（*p）才能对对象进行操作</u>，而<u>直接对引用做的修改都会直接改变引用所指向的对象</u>（本质上就是别名）
- 有const指针，没有const引用（引用本身就是必须初始化、不能改变的）
- 指针可以在使用中指向其他对象，引用只能是一个对象的引用，不能改变
- 有多级指针，没有引用的引用
- ++运算符对于指针和引用的意义不同
- 如果返回动态分配的内存或对象，必须使用指针，使用引用会引起内存泄露





#### typedef 和 #define 的区别

- typedef用来定义一种数据类型的别名，增加程序的可读性；#define用来定义常量，以及书写复杂、使用频繁的宏

- #define是宏定义，在<u>预处理</u>阶段起作用，编译器进行简单的<u>字符串替换</u>。#define的代码存储在代码段中

- typedef是<u>编译</u>过程的一部分，有类型检查的功能
- typedef有作用域的限制，#define不受作用域的约束





#### C的结构体和C++类

区别：

- 结构体不能有成员函数，类可以有
- 结构体默认都是public，类可以有private、public、protected访问限制、默认都是private
- 结构体没有继承关系，类有丰富的继承关系

共同点：

- 内存上，空的都占1字节，含有成员的都按照struct内存对齐方法分配内存





## C++ 面向对象

#### 面向对象三特性

- 封装：将客观事物封装成抽象的类，类可以把数据和方法暴露给可信的类或对象、也可隐藏
- 继承：可以用子类继承父类，子类无需编写代码就具有父类的所有功能，并能进行拓展
- 多态：一个类的实例的相同方法在不同情形下有不同的表现形式，使得不同内部结构的对象可以共享相同的外部接口
  - 静态多态：通过==重载、模板技术==实现，在==编译期间==确定
  - 动态多态：通过==虚函数、继承关系==实现，执行动态绑定，在==运行期间==确定
    - 动态多态的作用
      - 隐藏实现细节，使代码模板化，提高代码的可复用性
      - 接口重用，使派生类的功能可以被基类的指针调用，提高代码的可扩展性、可维护性
    - 动态多态的必要条件
      - 有继承，在继承关系之间体现多态
      - 有虚函数的覆盖，使用父类指针调用子类的功能
      - 有基类指针/引用指向子类对象





#### 动态绑定的实现（虚函数，虚函数表）

当编译器发现类中有虚函数时，会创建虚函数表，==把虚函数的入口地址放入虚函数表，并在对象中增加一个vptr，用于指向类的虚函数表==。

<u>当子类重写基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用子类覆盖后的虚函数，实现动态绑定</u>。（==vptr依然指向各自类的虚函数表，虚函数表内部的指针改变==）

- 虚函数表存放于常量区，类似于一个数组（存放指针，指向代码区的函数）
- vptr存放于对象中

虚函数表不针对对象，而是针对类。==类的所有对象共享类的虚函数表==。

- 每个vptr存放在各自对象的内存中，指向相同的地址——虚函数表

###### 构造函数、析构函数

- 构造函数不能是虚函数：调用虚函数需要通过vptr，在虚函数表中找到虚函数的入口，但vptr存放于对象中，不构造就没有vptr
- 析构函数最好是虚函数：
  - 为了实现动态绑定，基类指针指向子类对象
  - 如果析构函数不是虚函数，delete 基类指针时，调用基类的析构函数，子类的内存没有被释放
  - 如果析构函数是虚函数，delete 基类指针时，先调用子类析构函数，再自动调用基类析构函数，释放所有空间

- 构造函数可以抛出异常，但最好别
- 析构函数不能抛出异常：
  - 一旦抛出异常，之后的语句不执行，不会释放内存空间，造成内存泄漏
  - 此外，当异常发生时，C++通常调用析构函数释放资源，但析构函数抛出异常，形成套娃导致程序崩溃

###### 纯虚函数

含有纯虚函数的类是抽象类，不能实例化对象。





#### 对虚函数和多态的理解

多态的实现主要分两种：

- 静态多态，主要是重载，在编译时就确定
- 动态多态，用虚函数实现，在运行时进行动态绑定

重载：使用相同的函数名，但参数列表、返回值都可以自定义，编译器通过参数列表判断调用哪个函数

虚函数：每个类对应一个虚函数表，存在常量区，每个对象保存一个vptr指向虚函数表，虚函数表中存放指向虚函数的指针，如果子类重写了父类的虚函数，则在运行时修改这个指针，实现动态绑定、动态多态

- vptr：存在对象内存中，指向虚函数表
- 虚函数表：每个类的所有对象共享一个虚函数表，存在常量区，指向虚函数，运行过程中动态绑定
- 虚函数：存储在代码区

例子：一个父类指针指向子类对象，使用父类指针调用子类重写的虚函数时，会调用子类重写的函数。





#### 多继承

###### 多继承的问题

- 增加程序复杂度
- <u>父类之间，父类和子类之间出现同名成员时，出现同名二义性问题</u>，对成员访问的不确定性
  - 消除同名二义性的方法：
    - 使用作用域运算符 `::`，限定子类使用的是哪个父类的成员
    - 在子类中定义同名成员，覆盖父类的相关成员

- <u>子类从多个父类派生，而这些父类又从同一个基类派生，则在访问共同基类的成员时，会产生路径二义性</u>
  - 消除路径二义性的方法：
    - 消除同名二义性的两种方法都可以，子类再覆盖 或 使用作用域运算符 `::`
    - 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝





#### 类的成员函数重写（覆盖）、重载、隐藏

- 重写（覆盖）：
  - ==重写就是继承虚函数== 
  - 直接重写父类的方法，只发生在类的成员函数中
  - <u>函数名、参数列表、返回类型必须与父类完全相同</u>
  - <u>重写的父类中，被重写函数必须有virtual标识</u>
  - <u>虚函数重写实现动态绑定、动态多态（运行时多态）</u> 
- 重载：
  - 可以是类的成员函数，也可以是普通函数（重载运算符等）
  - 两个函数具有==相同的函数名==，但==参数列表不同，不关心返回值==
  - 调用时，根据传递的参数列表，判断调用哪个函数
  - <u>重载实现静态多态（编译时多态）</u> 
- 隐藏：
  - 指父类的函数在子类中被隐藏了（无法调用），主要有：
    - 子类函数和父类函数 名称相同，但参数不同
    - 子类函数和父类函数 名称相同，参数相同，但父类函数没有 virtual
  - 子类函数和父类函数 名称相同，参数相同，父类函数有 virtual 就是重载





#### C++ 的四种 cast 类型转换

###### 总览

- const_cast：去掉变量的const、volatile、__unaligned属性
- static_cast：
  - 不进行安全检查
  - 主要执行非多态类型的转换，各种基本数据类型之间的转换、从子类到父类的安全转换
- dynamic_cast：只能用于存在虚函数的父子关系之间的强制类型转换
  - 进行运行时安全检查
  - 主要执行多态类型的转换，子类和父类之间双向的转换
  - ==转换的类型必须是指针或引用类型，只能用于含有虚函数的类==
  - 如果转换不成功，对指针类型会返回nullptr，对引用类型会抛出bad_cast异常
- reinterpret_cast：
  - 几乎什么都可以转，比如int转指针，可能出问题
  - 偏向于“重解释”一个指针
  - 在两个地址类型之间的不安全转换



在整个层次结构中移动指针

- 子类转化为父类安全（向上转换）
- 父类转化为子类不安全（因为父类不拥有全部的子类方法）

C语言的强制类型转换虽然看起来什么都可以转，但转化不够明确、不能进行错误检查，容易出错。

###### static_cast

- <u>用于非多态类型的转换，不执行运行时类型检查</u> 
  - 用于==<u>基本数据类型之间的转换==、==子类向父类==的安全转换、==`void*` 和其他类型指针之间的转换==</u> 
- 通常用于转换数值类型（float -> int）

###### dynamic_cast

- <u>只能够用在指向类的指针或引用上（或void\*），转换的目的是确保目标指针类型所指向的是一个完整且有效的对象</u> 
- 用于多态类型的转换，执行运行时类型检查
  - <u>用于==子类和父类之间==的安全转换（双向）</u>，因为编译器默认向上转换总是安全的，且向下转换dynamic_cast可以自动检查类型
- dynamic_cast 转换失败时，对指针返回nullptr，但不引发异常；对引用会返回 bad_cast 异常

###### const_cast

- <u>用于删除const、volatile、__unaligned特性</u>（如将 const int 转换成 int）

###### reinterpret_cast

- 理解为指针的“重解释”，可以转换指针的类型，不进行类型检查比较危险
- 能够完成任意指针类型向任意指针类型的转换即使它们毫无关联。该转换的操作结果是出现一份完全相同的二进制复制品，既不会有指向内容的检查，也不会有指针本身类型的检查。
- 也能够完成指针向整数的转换。不过该整数的类型取决于平台。唯一的保证是该整数的类型能够容纳下指针的值以及能够再次被转换成一个有效的指针。
- 用于<u>不同类型指针之间、不同类型引用之间、指针和能容纳指针的整数类型之间</u>的转换





#### C++的空类有哪些成员函数

- 缺省的构造函数
- 缺省的拷贝构造函数
- 缺省的析构函数
- 赋值运算符 = 
- 取地址运算符 &
- 取地址运算符 const &

这些函数只有在第一次被调用时，才会被编译器创建。==所有这些函数都是 inline 和 public 的==。

```c++
class A{}

// 空类编译后，相当于：
class A{
public:
    A();			// 构造函数
    A(const A&);	// 拷贝构造函数
    ~A();			// 析构函数
    A& operator=(const A&);	// 赋值运算符
    A* operator&();			// 取址运算符
    const A* operator&();	// 取址运算符const
}
```

- 默认析构函数是非虚函数（除非基类有自己声明的虚析构函数）
- 默认的拷贝构造函数和赋值运算符=都是浅拷贝
  - 赋值操作符=只有在生成的代码合法时才会生成
    - 如果向在内含==引用成员、指针成员、const成员==的类中支持赋值操作，就必须自己定义赋值运算符=
-  当基类将自己的赋值操作符声明为private时，子类就不会产生自己的赋值操作符





#### 拷贝构造函数和赋值运算符重载的区别

- 拷贝构造函数用于<u>构造新的对象</u> 
- 赋值运算符重载用于<u>将源对象的内容拷贝到目标对象中</u>，若源对象中包含未释放的内存要先释放

```c++
Student s;
Student s1 = s;	// 隐式调用拷贝构造函数，新对象s1
Student s2(s);	// 显式调用拷贝构造函数，新对象s2

Student s3;
s3 = s;			// 使用赋值运算符，没有新对象
```

一般情况下，<u>类中含有指针成员变量时，需要重载拷贝构造函数、赋值运算符、析构函数</u>，避免浅拷贝造成内存泄漏。



拷贝构造函数和赋值运算符的行为比较相似，都是将一个对象的值复制给另一个对象，但是其结果却有些不同

- ==拷贝构造函数使用传入对象的值生成一个新的对象的实例==，
- ==赋值运算符是将对象的值复制给一个已经存在的实例==

这种区别从两者的名字也能轻易的分辨出来，<u>拷贝构造函数也是一种构造函数，那么它的功能就是创建一个新的对象实例；赋值运算符是执行某种运算，将一个对象的值复制给另一个对象（已经存在的）</u>。

调用的是拷贝构造函数还是赋值运算符，主要是看==是否有新的对象实例产生==，如果产生了新的对象实例，那调用的就是拷贝构造函数；如果没有，那就是对已有的对象赋值，调用的是赋值运算符。





#### 拷贝初始化、直接初始化，初始化和赋值的区别

- `ClassTest ct1("ab");` <u>直接初始化</u>。不调用拷贝构造函数，==直接调用构造函数==
  - 因此，当构造函数私有化后，这条语句也可以执行
- `ClassTest ct2 = "ab";` <u>拷贝初始化</u>。==首先调用构造函数== `ClassTest(const char* pc){}`，创建一个临时对象，==然后调用拷贝构造函数==，将临时对象作为参数构造对象 ct2
  - 当拷贝构造函数私有化后，该语句不能编译通过
- `ClassTest ct3 = ct1;` <u>拷贝初始化</u>。ct1 已存在，不需调用构造函数，而==直接调用拷贝构造函数==，把值赋值给 ct3
  - 当拷贝构造函数私有化后，该语句不能编译通过

- `ClassTest ct4(ct1);` <u>直接初始化</u>。ct1 已存在，==直接调用拷贝构造函数==，生成 ct4

拷贝初始化和直接初始化调用的构造函数是不一样的，但当类进行拷贝时，类会自动生成一个临时对象，然后再进行拷贝初始化。



总结来说：

- 有类型，并且有赋值运算符=的，都是拷贝初始化，==调用拷贝构造函数==。如果想像 unique_ptr 那样禁止拷贝，将拷贝构造函数私有化即可。
  - 赋值运算符=右边如果是已有的对象，就不调用构造函数
  - 否则==调用构造函数==，初始化对象或者临时对象

- 不用赋值运算符=，而是用括号的，都是直接初始化
  - 如果括号内提供构造的参数，就==直接调用构造函数== `ClassTest ct("ab");`
  - 如果括号中是对象，就依然==调用拷贝构造函数== `ClassTest ct(ct1);`
- <u>只要用到拷贝构造函数，一旦拷贝构造函数私有化，编译都不通过</u> 
- <u>只用到构造函数（括号内给参数）的初始化，构造函数初始化后编译也可以通过</u> 



###### 实现一个不可复制的类

```c++
class noncopyable{
private:
    noncopyable(const noncopyable&){}				// 拷贝构造函数私有化
    noncopyable& operator=(const noncopyable&){}	// 赋值运算符私有化
public:
    noncopyable(){}				// 构造函数公有
    virtual ~noncopyable(){}	// 析构函数公有、虚函数
}

```





#### 模板函数和模板类，模板特例化







## C++ STL

#### STL分类

- 算法：排序，复制等常用算法，和不同容器特定的算法
- 容器：数据的存放形式，包括<u>序列式容器list、vector等</u>，<u>关联式容器set、map等</u>
- 迭代器：在不暴露容器内部结构的情况下，对容器遍历





#### STL 容器一览

- 顺序容器：存储的是对象
  - array\<T, N\> 数组：固定大小，随机访问，不能插入删除元素
  - vector\<T\> 动态数组：随机存取，尾部插入、删除很快；动态数组实现，连续存储
  - deque\<T\> 双向队列：随机存取，首位插入、删除很快；双向队列实现，连续存储
  - list\<T\> 双向链表：只支持双向顺序访问，任何位置插入、删除都很快；双向链表实现，不连续
  - forward_list\<T\> 单向链表：只支持单项顺序访问，任何位置插入、删除都很快
- 关联容器：存储的是结点，对指针进行操作
  - map
    - map\<K, T\> 关联数组：用于保存键值对，自动去重、排序，红黑树实现
    - multimap\<K, T\> ：关键词可重复的map
    - unordered_map\<K, T\> ：用哈希表实现的map，不自动排序，读取更快、建立和扩容更慢
    - unordered_multimap\<K, T\>：关键词可重复出现的unordered_map
  - set
    - set\<T\>：只保存关键字，自动去重、排序，红黑树实现
    - multiset\<T\>：关键字可重复出现的set
    - unordered_set\<T\>：用哈希表实现的set
    - unordered_multiset\<T\>：关键词可重复出现的unordered_set
- 容器适配器：
  - stack\<T\> 栈
  - queue\<T\> 队列
  - priority_queue\<T\> 优先队列





#### vector

###### vector的底层原理

- vector是一个==动态数组==，包含三个迭代器：start和finish之间是已被使用的空间，end_of_storage是整块连续空间（包括备用空间）的尾部
- vector在内存中的空间是连续的，要求存储的元素是对象（不能是引用）
  - <u>vector可以随机存取</u> 
- ==vector的内存增长机制==：当空间装不下 `vec.push_back(val);` 时，自动申请另一片更大的空间（1.5倍或2倍），然后<u>把原来的数据拷贝到新的内存空间</u>，然后<u>释放原来的内存空间</u>
  - 不是在尾部继续扩容，而是申请新的空间并转移数据
  - 因为vector是数组，在堆中占用连续的内存。不能保证尾部有足够的连续空间了
  - <u>对vector的任何操作一旦引起了空间重分配，指向原来vector的所有迭代器都会失效</u> 

- `vec.clear()` 时，<u>内存空间不释放，仅清除所有数据</u>

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\10.png" alt="70" style="zoom:67%;" />

###### vector 的常用函数

```c++
vector<int> vec(10, 100);	// 创建10个元素，值都是100
vec.reserve(20);
vec.resize(r, vector<int>(c, 0));	// 二维数组初始化
reverse(vec.begin(), vec.end());	// 翻转元素
sort(vec.begin(), vec.end());	// 默认升序排序
vec.push_back(val);				// 尾部插入
vec.size();						// 返回存储元素的个数
find(vec.begin(), vec.end(), 1);	// 查找元素
iterator = vec.erase(iterator);		// 删除元素
```

- size 和 capacity
  - size：当前vector中有多少个元素（finish - start）
  - capacity： vector 分配的内存可以容纳多少元素（end_of_storage - start）
- reserve 和 resize
  - reserve 是<u>直接扩充到已经确定的大小（end_of_storage），避免由一步步 push_back 超过容量造成的多次开辟、转移、释放的问题</u>。只有一个参数
  - resize 可以<u>改变有效空间capacity的大小</u>。可以有多个参数

- vector 的元素类型可以是引用吗
  - vector <u>底层要求连续的对象排列</u>，引用只是别名不是对象（指针是对象），不能存到 vector 里

- 什么时候迭代器失效
  - 当内存重分配，指向原内存的所有迭代器会失效
  - 当删除容器中一个元素时，指向该元素的迭代器被删除，造成迭代器失效
    - <u>erase方法会返回下一个有效的迭代器</u>，因此删除某个元素时 `it = vec.erase(it);`

- 正确释放 vector 的内存
  - `vec.clear()` 只清空内容，不释放内存
  - `vector().swap(vec)` 清空内容、释放内存，得到一个新的vector
  - `vec.shrink_to_fit()` 降低capacity到和size匹配
  - `vec.clear(); vec.shrink_to_fit();` 两句分别实现清除内容、释放内存

###### vector如何释放空间

vector的内存占用空间只增不减，比如先分配1000个，erase后999个，留下一个有效元素，但内存占用仍是1000个。

vector被析构的时候，所有的内存空间才回收。

如果需要空间动态缩小，可以考虑使用deque（双端队列、连续空间）、list（双向链表、不连续空间）

- empty()检查容器是否为空，clear()可以清空所有元素，但不解除内存空间

- swap()可以用来帮助释放内存 `vector(Vec).swap(Vec);` 将Vec的内存清除





#### list

###### list的底层原理

list底层是一个==双向链表==，以结点为单位存储数据，结点的地址在内存中不一定连续。每次增/删一个元素，就配置/释放一个元素空间。

<u>list不支持随机存取，适合需要大量插入删除，不关心随机存取的应用场景。</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\11.png" alt="70" style="zoom:67%;" />

###### list 的常用函数

```c++
list.push_back(elem);	// 在尾部插入一个元素
list.pop_back();		// 尾部删除一个元素
list.push_front(elem);	// 头部插入一个元素
list.pop_front();		// 头部删除一个元素
list.size();		// 返回容器中存储的元素个数
list.sort();		// 默认升序排序
list.unique();		// 移除数值相同的连续元素
list.back();		// 获取尾部迭代器
lsit.erase(iterator);		// 删除迭代器指向的元素，返回下一个迭代器
```

跟vector一样，erase操作返回下一个有效的迭代器。





#### deque

###### deque的底层原理

deque是一个双端队列（双向开口的连续线性空间），在头、尾两端进行元素的增删操作都是O1的时间复杂度。

deque、vector、list的比较：

- vector可以随机存取数据，但在非尾部增删数据时效率很低，扩容复杂
  - 适合对象简单、数量变化不大、随机存取频繁的元素存储
  - deque的迭代器比vector复杂很多，尽可能使用vector而不是deque
- deque可以随机存取数据，从首尾两端进行插入删除操作复杂度O1
- list不支持随机存取
  - 适合对象大、数量变化频繁、插入删除频繁的元素存储
- vector的erase()删除迭代器指向的元素，返回下一个可用元素的迭代器，但不释放内存空间；deque在两端删除内容的同时删除内存

###### deque的常用函数

```c++
deque.push_back(elem);	// 尾部插入元素
deque.pop_back();		// 尾部删除元素
deque.push_front(elem);	// 头部插入元素
deque.pop_front();		// 头部删除元素
deque.size();		// 返回存储元素个数
deque.at(idx);		// 传回索引idx所指向的数据，如果idx越界，抛出 out_of_range 异常 	
```





#### 红黑树

###### 红黑树的由来

二叉排序树BST：中序遍历是递增的序列

- 若左子树不空，则左子树上所有结点的值都小于根结点的值

- 若右子树不空，则右子树上所有结点的值都大于根结点的值
- 具有递归性

当创建二叉排序树时，元素序列恰好是有序的，二叉排序树就退化成链表，<u>搜索效率大幅降低</u>。

- 正常的二分排序树，搜索效率类似于二分查找 O(logn)
- 链表的搜索效率 O(n)

==为了解决退化问题，发明了平衡二叉树和红黑树==：

- 平衡二叉树AVL：
  - 平衡二叉树必须是排序二叉树
  - 左右子树的深度之差的绝对值不超过1，且左右子树也是平衡树

- 红黑树RBT：
  - 红黑树必须是排序二叉树，不是严格的平衡二叉树
  - 在每个结点增加一个存储位，表示结点的颜色



###### 红黑树的特性

- 每个结点分红黑两色
- 根结点永远是黑色
- 叶子结点都是空结点null，都是黑色
- 每个红色结点的两个子结点都是黑色（父子结点不能同时为红色，但可以同时为黑色）
- <u>从任意结点到其子树中每个叶子结点的路径都包含相同数量的黑色结点</u>（黑色高度相同）

由这五条性质可以推出：<u>红黑树在最差情况下，最长路径都不比最短路径长2倍</u>

- 由于任意节点到每个叶子结点的路径，黑色结点数量相同
  - 最好情况下，路径上全是黑色结点
  - 最差情况下，每两个黑色结点中间有一个红色结点

==排序二叉搜索树BST有不平衡的问题，可能左子树很长但是右子树很短，造成查询时性能不佳（Ologn退化成On）；完全平衡的二叉树能保证层数平均，从而查询效率高，但是维护又很麻烦，每次插入和删除有很大的可能要大幅调整树结构。==

==红黑树就是介于完全不平衡和完全平衡之间的一种二叉树，通过每个节点有红黑两种颜色、从节点到任意叶子节点会经过相同数量的黑色节点等一系列规则，实现了【树的层数最大也只会有两倍的差距】，这样既能提高插入和删除的效率，又能让树相对平衡从而有还不错的查询效率。== 



从平衡二叉树AVL，扩展每个结点能存储的关键字个数：

###### B树

B树属于多叉树，又名平衡多路查找树（查找路径不止2）

- 左小右大，中序遍历的结果是递增排序
- 每个结点至多M颗子树、至多M-1个关键字
- ==每个结点的关键字个数不只2个， <= M-1== 
- ==所有叶子结点均在同一层== 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\13.png" alt="70" style="zoom:67%;" />

B树相对于平衡二叉树的不同是，每个结点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来），<u>把结点大小限制在磁盘块大小范围，充分使用磁盘块大小空间</u>；树的<u>结点关键字增多后，树的层级比原来的二叉树少了，减少数据查找的次数和复杂度</u>。

<u>（跟平衡二叉树AVL相比，B树每个结点包含的关键字增加，并且所有叶子节点均在同一层。充分利用空间 + 降低并平衡层数）</u> 



###### B+树

相对于B树，更充分利用了结点空间、让查找速度更接近二分。

- ==B+树的非叶子结点不保存关键字指针==，只进行数据索引，使得每个非叶子结点能保存的关键字数量大幅增加
- ==B+树叶子结点保存了父结点的所有关键字指针==，所有数据地址必须到叶子结点才能获取到，所以每次查询次数都一样
- ==B+树叶子结点的关键字从小到大排序，左边的结尾数据会保存右边结点开始数据的指针==，所有的叶子结点组成一个有序的大链表

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\14.png" alt="70" style="zoom:67%;" />

B+树的特点：

- 层级更少：因为结点不保存关键字的指针，存储的索引信息更多
- 查询速度更稳定：所有关键字的数据地址都存在叶子结点上，每次查找次数相同
- 天然排序：所有叶子结点数据构成一个有序链表
- 遍历更快：只需遍历所有叶子结点，就遍历了整棵树，不需像B树一样逐层遍历，有利于数据库做全表扫描

<u>（跟B树相比，B+树结点的地址全部存到叶子结点中，叶子结点形成有序链表）</u>



###### B*树

- ==B*数比B+树增加了兄弟结点之间的指向关系，结点满了会向兄弟结点转移关键字==
- B+树初始化的关键字初始化个数是ceil(m/2)，b\*树的初始化个数为（ceil(2/3\*m)）
- B+树结点满时就会分裂，而B\*树结点满时会检查兄弟结点是否满（因为每个结点都有指向兄弟的指针），如果兄弟结点未满则向兄弟结点转移关键字，如果兄弟结点已满，则从当前结点和兄弟结点各拿出1/3的数据创建一个新的结点出来

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\15.png" alt="70" style="zoom:67%;" />

（跟B+树相比，B*树每个结点分配的关键字数量更多，并且结点存有兄弟结点的指针，在结点满时会像兄弟结点转移）





#### map，set，multiset，multimap

###### map，set，multiset，multimap 的底层原理

它们的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux中CFS进程调度算法也用到红黑树。



###### map 的查找

对于STL的map容器，count和find方法都可以判断一个key是否出现

- `mp.count(key) > 0` ，只能是0或1，因为不允许有重复的key
- `mp.find(key) != mp.end()` 

[] 和 find 的区别：

- `mp[key] == "target"` 将key作为下标执行查找，并返回相应的值；如果不存在这个key，就新建一个具有该key和默认value的元素插入map
- `mp.find(key) != mp.end()` 用key执行查找，找到了返回该位置的迭代器；如果不存在这个key，就返回尾部迭代器

###### map的插入方式

- insert pair：`mp.insert(pair<int, string>(1, "lihua"));` 
- insert value_type：`mp.insert(map<int, string>::value_type (1, "lihua"));` 
- insert make_pair：`mp.insert(make_pair(1, "lihua"));` 
- 使用数组直接访问：`mp[1] = "lihua";`



###### map，set，multiset，multimap 的特点

- set和multiset会根据特定的排序准则，自动将元素排序
  - set不允许元素重复，multiset中的元素可以重复

- map和multimap将key和value组成的 pair 作为元素，根据 key 的排序准则，将元素自动排序（<u>因为map是红黑树，也是二叉搜索树BST，所以默认是按key排序的</u>）
  - map不允许key重复，multimap中的key可以重复

- ==map和set都是红黑树，增删改查操作的复杂度都是O(logn)==

###### map和set的区别

- map的元素是 key-value 对；set 只是关键字的简单集合，每个元素只包含一个关键字
- <u>set 的迭代器是const的，只能存取，不允许修改元素的值；map允许修改value，但不允许修改key的值</u> 
- map支持下标操作（用key作下标），set不支持



###### Q：为何map和set的增删效率比其他序列容器高，并且insert后，以前保存的iterator不会失效？

- ==序列容器存储的是对象，需要进行内存拷贝、内存移动等操作==

- 而==关联容器存储的是结点，不需要内存拷贝和内存移动==
  - 插入操作只是结点指针进行左旋右旋等一系列操作，结点的内存并没有改变
  - iterator同理，iterator就如同指向内存的指针，内存没变指针也不失效
- 对于vector，如果push_back引发扩容，会将原来的空间舍弃，之前的iterator自然就失效了

###### Q：为何map和set不能像vector一样，有一个reserve函数用来预分配数据？

- 因为在map和set内部，存储的不是元素本身，而是包含元素的结点。



###### map，set，multiset，multimap 的常用函数

```c++
bool b = mp.empty();	// 是否为空
iter = mp.find(key);	// 寻找键值为key的元素，返回地址（迭代器）
int m = mp.size();		// 已存在元素的数量
mp.insert({103, "helloworld"});	// 以键值对的形式插入元素

for(map<int, string>::iterator iter = mp.begin(); iter != mp.end(); ){
    if(iter->second == "target")	// key = iter->first, value = iter->second
        mp.erase(iter++);			// erase之后，iter指向后继有效单元
    else ++iter;
}
```





#### map 和 hash_map

C++ 11标准没有hash_map，但出于编译器扩展的目的，一些库将它实现了。

###### 异同

相同点：

- 都是STL的关联式容器
- 元素类型都是键值形式：`pair<const key, data>` 
- 键唯一性，没有两个元素拥有相同的key

不同点：

- hash_map 是<u>哈希关联容器</u>，使用<u>哈希表</u>实现，大多数插入、查找的时间复杂度是O(1)级别
  - hash_map 是用hash table实现的关联容器，元素不进行排序，最差复杂度O(n)，平均复杂度O(1)
  - 在不要求排序，只要求存取的场合，哈希关联容器的效率远高于排序关联容器
- map是<u>排序关联容器</u>，使用<u>红黑树</u>实现，增删改查的操作的时间复杂度是O(log(n))级别



###### 哈希表

一个哈希表包含一个数组，通过特殊的关键码（key）来访问数组中的元素。哈希表的主要思想是通过一个<u>哈希函数</u>， 把关键码映射的位置去寻找存放值的地方 ，读取的时候也是直接通过关键码来找到位置并存进去。

常见的哈希函数算法：

- 直接定址法，`f(key) = key` 或 `f(key) = a*key + b` 
- 除留余数法，`f(key) = key % p, p < m`，最常见
- 数子分析法，平方取中法，随机数法等

哈希冲突：`key1 != key2, f(key1) = f(key2)`。解决方法：

- 开放地址法：在散列表中寻找下一个空的位置
  - 线性探查法，二次散列法，双哈希函数法
- 链地址法：哈希值相同的元素使用链表存放，<u>hash_table 内部也是这样实现的</u> 

哈希表的基本思路是空间换时间。<u>大多数情况下查找或者插入元素的时间复杂度可以达到O(1)， 时间主要花在计算hash值上。然而也有一些极端的情况，最坏的就是hash值全都映射在同一个地址上，这样哈希表就会退化成链表，时间复杂度会变为O(n)。</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\8.png" alt="70" style="zoom:67%;" />



<u>哈希表在扩容的时候特别花费时间，因为所有的元素都需要重新进行哈希</u>。 



###### 应用对比

- 数据量：

- 时间：hash_map <u>操作速度</u>比 map 快，但 <u>hash 函数以及解决冲突</u>都需要额外的时间，且 hash_map <u>构造速度</u>比 map 慢
- 内存空间：hash_map 用空间换时间，内存消耗高



###### C++ 中 hash_table 的实现

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\9.png" alt="70" style="zoom:67%;" />

- 使用拉链法解决冲突
- bucket维护的若干“拉链”不是由STL的双向链表li·st实现，而是使用hashtable_node自定义的linked_list
- bucket本身使用vector存储
- 内置28个质数[53, 97, 193,...,429496729]，创建 hash_table 时根据存入元素个数，选择一个大于个数的质数作为 hash_table 的容量（vector的长度），每个 bucket 维护的 linked-list 长度也等于 hash_table 的容量
  - 如果插入hash_table的元素个数超过了容量，就重建 hash_table





#### unordered_map 和 unordered_set

###### unordered_map 和 unordered_set 的底层原理

unordered_map 是一个防冗余的哈希表（==哈希函数采用除留余数法，冲突使用拉链法==）。用空间换时间，可以在 O(1) 的复杂度插入、查找数据。

###### unordered_map 和 map

- unordered_map 自动去重，但是不排序，常用作hash表；而 map 是红黑树，使用它的自动排序特性

- unordered_map 是哈希表，bucket是vector，每个拉链是一个链表。
  - 空间：<u>哈希表是空间换时间，需要很大的存储空间</u> 
  - 查找时间：O(1)
  - 新建、扩容：<u>哈希表构造速度慢（有hash函数的耗时和去冲突的耗时），扩容需要进行重新哈希，十分耗时</u> 
- map 是红黑树，存储的是结点，操作的是指针
  - 空间：红黑树需要的空间比较小，也不需要连续的内存空间
  - 查找时间：O(logn)
  - 新建、扩容：红黑树新建和扩容都不需要很长时间

###### unordered_map 和 unordered_set 的常用函数

```c++
unordered_map<int, string> mp;
mp.begin();		// 返回指向起始位置的迭代器，iterator类型
mp.end();		// 返回指向末尾位置的迭代器，iterator类型
mp.cbegin();	// 返回指向起始位置的常迭代器，const_iterator类型
mp.cend();		// 返回指向末尾位置的常迭代器，const_iterator类型
mp.size();	
mp.insert({key, value});
mp.find(key);
mp.count(key);	// 返回给定主键的元素的个数
```





#### 迭代器

迭代器用于提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。

###### 迭代器和指针

- 迭代器不是指针，是类模板，模拟了指针的一些功能，重载了指针的一些操作符（->、*、++、--等）
- 迭代器封装了指针，是一个“可遍历STL容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，可以根据不同类型的数据结构来实现不同的++，--等操作。
- 迭代器返回的是对象引用而不是对象的值，所以std::cout只能输出迭代器使用*取值后的值，而不能直接输出迭代器自身

###### 迭代器的底层机制

- ==萃取技术 traits==：<u>进行类型推导，根据不同类型，执行不同的处理流程</u> 
  - 如容器是vector，traits 推导出其迭代器类型为随机访问迭代器；容器是list，是双向迭代器
  - 如STL算法库\<algorithm\>中的distance函数，接受两个迭代器参数，然后计算他们两者之间的距离
    - vector容器是动态数组，内存是连续分配的，因此指针直接相减即可获得两者的距离
    - list容器是双向链表，内存一般不连续分配，因此只能一级一级地调用next()或其他函数，再判断迭代器是否相等，来计算距离
    - vector迭代器计算distance的时间复杂度是O(1)，list迭代器是O(n)
- 使用萃取技术进行推导的过程中，会使用到==模板偏特化==，用来推导参数

```c++
// 需要在T为int类型时，Compute⽅方法的参数为int，返回类型也为int，
// 当T为float时，Compute⽅方法的参数为float，返回类型为int
template <typename T>
class Test {
public:
	TraitsHelper<T>::ret_type Compute(TraitsHelper<T>::par_type d);
private:
	T mData;
};

template <typename T>
struct TraitsHelper {
	typedef T ret_type;
	typedef T par_type;
};

// 模板偏特化，处理理int类型
template <>
struct TraitsHelper<int> {
	typedef int ret_type;
	typedef int par_type;
};

// 模板偏特化，处理理float类型
template <>
struct TraitsHelper<float> {
	typedef float ret_type;
	typedef int par_type;
};
```

###### 迭代器的种类

- 输入迭代器：是只读迭代器，在每个被遍历的位置上只能读取一次，如find函数的参数
- 输出迭代器：是只写迭代器，在每个被遍历的位置上只能被写一次
- 前向迭代器：兼具输入输出能力，可对同一位置重复读写，但不支持operator-，只能向前移动
- 双向迭代器：很想前向迭代器，但可以双向移动
- 随机访问迭代器：有双向迭代器的所有功能，同时提供“迭代器算术”，可以跳跃到任意位置；包含指针的所有操作，进行随机访问、移动指定步数等
  - 具有以上四种iterator的全部操作，并支持 iter+=n、iter-- 、iter1-iter2、iter[4] 等操作

###### 迭代器失效的问题

- 插入操作
  - 对于vector和string（动态数组，连续）
    - 如果容器内存被重新分配，迭代器、指针、引用全部失效
    - 如果容器内存没有重新分配，插入点前的迭代器有效，插入点后的因为要移位，所以失效
  - 对于deque（双端队列，连续）
    - 如果插入点位于除了front和back的其他位置，迭代器、指针、引用全部失效
    - 如果插入到front或back，迭代器失效，但指针、引用有效
  - 对于list和forward_list（双向链表，不连续）
    - 所有的迭代器、指针、引用有效

- 删除操作
  - 对于vector和string（动态数组，连续）
    - 删除点之前的迭代器、指针、引用有效，之后的失效；off-the-end的迭代器总是失效
  - 对于deque（双端队列，连续）
    - 如果删除点位于除了front和back的其他位置，迭代器、指针、引用全部失效
    - 如果删除front或back，off-the-end失效，其他的迭代器、指针、引用有效
  - 对于list和forward_list（双向链表，不连续）
    - 所有的迭代器、指针、引用有效
  - 对于关联容器map和set
    - 由于存储的是结点而不是对象本身，操作都是针对迭代器指针操作
    - 如果一个元素被删除，那么其对应的迭代器就失效了，不会影响其他迭代器的有效





#### 容器删除元素

- 对于顺序容器，<u>erase不仅使当前迭代器失效，而且使后面的迭代器都失效，不能采用 erase(iter++) 的方式</u>。但会返回下一个有效迭代器
  - `iter  = erase(iter);`
- <u>对于关联容器，erase只让被删除元素的迭代器失效，但返回void，所以要采用 erase(iter++) 的方式</u> 
  - `erase(iter++);` 





#### STL 内存优化

STL内存管理使用==二级内存配置器==

- 第一级配置器
  - ==第一级内存配置器只是对malloc()、free()函数的简单封装，在allocate内调用malloc()，在deallocate()内调用free()。同时，第一级配置器的omm_malloc()函数用来处理malloc失败的情况== 
  - 以malloc()、free()、realloc()等C函数，执行实际的内存管理，在内存需求不被满足的时候，调用一个指定的函数
  - 一级内存空间配置器分配的是大于128字节的空间，如果分配不成功，调用句柄，是放一部分内存；如果还是不成功，抛出异常
- 第二级配置器
  - 第一级配置器带来几个问题：内存分配释放效率低；配置大量小内存块时，内存碎片化严重；配置内存需要额外空间存储内存块信息，造成额外内存负担
  - 如果分配的区块 <128 Bytes，则用内存池管理：==第二级配置器维护了一个自由链表数组，每次需要分配内存时，直接从相应的链表上取出一个内存结点即可==，效率很高
  - 自由链表数组free_list：
    - 其实是个<u>指针数组，每个指针元素指向一个链表的起始结点</u> 
    - 数组大小为16，相当于维护了16个链表，<u>链表的每个结点就是实际的内存块</u> 
      - 相同链表上的内存块大小相同，不同链表上的内存块大小不同，从8一直到128
  - “一物两用”：由类型“union”可知，指针free_list_link和数组client_data共享一段内存空间。当指针free_list_link指向下一个节点时，client[0]内存储的内容为下一个节点的前一个字节大小的地址（实际上，现在数组client_data并没有使用到）。但当用户需要使用小额区块，即使用client_data数组的时候，free_list_link内存储的下一个节点的地址数据将被覆盖掉，故而free-list也就不再指向它们。

```c++
// free_list 的结点结构
union obj{
	union object* free_list_link;
	char client_data[8];	// 从8到128
}
```

- 内存分配：
  - ==allocate函数内先判断要分配的内存大小== 
    - ==若 > 128 Bytes，直接调用第一级配置器==，使用封装的库函数分配内存
    - ==< 128 Bytes，根据要分配的内存大小，从free_list的16个链表中选出一个链表==，取出该链表的第一个节点返回。如果相应链表为空，就用refill()函数，填充该链表
      - refill()函数内，先调用chunk_alloc()函数，==从内存池分配默认为20个链表结点大小的内存==（一整块。内存池内存不足时，返回的内存块小）
      - 然后，==refill()函数将这一大块内存分成20等分，并连接起来形成链表==，将这个链表返回

- 内存池：
  - chunk_alloc()函数内管理了一块内存池，当refill函数要填充链表时，就会调用chunk_alloc函数，从内存池取出相应的内存
  - 如果内存池的内存够20个结点的链表，就返回；如果不够，就少返回几个结点的链表
  - 如果一个结点的内存块都无法提供，就将内存池的这一点内存分配给其他合适的链表，然后调用malloc()函数，申请所需两倍的内存
    - 如果malloc()成功，返回相应内存大小给refill()
    - 如果malloc()失败，会搜索其他链表的可用内存块，添加到内存池，再调用chunk_alloc()分配内存池的内存
      
      - 如果其他链表也无内存块可用，则只能调用第一级空间适配器
      
        







## C++ 内存管理

#### new/delete 和 malloc/free 

- new/delete 是C++的关键字，malloc/free 是C语言stdlib.h库中的库函数
- 静态和动态
  - <u>malloc/free必须明确大小</u>，并且<u>只操作内存、不操作对象，不能用在动态类上</u>
  - <u>new/delete会自动进行类型检查、确定大小</u>，并且<u>有构造、析构操作，可以用于动态对象</u>
  - new一般分两步：<u>new内存、构造</u> 
    - new操作对应malloc，但new操作也可以重载、自定义分配策略（不分配、分配到非内存设备上都可以），但malloc只能分配到内存的堆区
    - 构造操作调用构造函数
  - delete调用析构函数，free不调用析构函数
- new类型是安全的，malloc不是安全的
  - 分配时，进行类型检查
    - `int* p = new float[2];` 编译器会报错
    - `int p = malloc(2*sizeof(int));` 编译时编译器不报错
  - 分配不成功时，两者都返回空指针
    - <u>new会抛出异常</u> 
    - malloc需要用return终止函数或exit终止程序
- new/delete 直接带具体类型的指针，malloc和free返回void类型的指针

```c++
int* p = new int[2];
int* q = (int*)malloc(2 * sizeof(int));	// malloc返回void*，需强转成int*，相对的不安全
```

delete和free被调用后，内存不会立即回收，指针也不会指向空。只是告诉OS这一块内存被释放了，可以做其他用途。

由于没有重新对这块内存进行写操作，内存中的变量没有发生变化，出现野指针的情况。因此，释放内存后应该将指针赋值nullptr。





#### delete 和 delete[]

```c++
int* a = new int(1);
delete a;

int* b = new int(2);
delete [] b;

int* c = new int[11];
delete c;

int* d = new int[12];
delete [] d;
```

- 对于简单类型，使用new分配内存后，不管是不是数组形式，两种方式都可以释放内存
- 对于自定义类型，需要<u>对单个对象使用delete，对对象数组使用delete[]，逐个调用数组中的对象的析构函数，从而释放所有内存</u> 
  - 如果反过来使用，其行为是未定义的
- 最恰当的方式：如果用new，就用delete；如果用 new []，就用 delete []





#### 内存块太小，导致malloc和new不成功、返回空指针，如何处理

- 对于malloc，需要判断其是否返回空指针，如果是，马上用return终止函数或用exit终止程序
- ==对于new，默认抛出异常==，可以catch

```c++
try{
    int* ptr = new int[10000000];
} catch(bad_alloc &memExp){
    cerr << memExp.what() << endl;
}
```

- new还可以使用 `set_new_handler` 函数
  - 如果new不能满足内存分配请求，`no_more_memory` 会反复调用，所以 `set_new_handler`函数必须完成：
    - 让更多内存可被使用：可以在程序一开始，分配一大块内存，当`set_new_handler`第一次被调用时，将这些内存释放，还给程序使用
    - 使用另一个 `set_new_handler`
    - 卸除 `set_new_handler`：返回空指针，这样new会抛出异常
    - 直接抛出bad_alloc异常
    - 调用abort或exit

```c++
void no_more_memory() {
	cerr << "Unable to satisfy request for memory" << endl;
	abort();
}
int main() {
	set_new_handler(no_more_memory);
	int *ptr = new int[10000000];
}
```





#### 内存泄漏

###### 内存泄漏的场景

- 分配内存未释放：new/delete没有成对出现，malloc/free没有成对出现
  - 在堆中创建对象分配内存，但未显示释放内存。如在局部分配内存，未在调用者函数体内释放
  - 在构造函数中动态分配内存，但未在析构函数中正确释放内存

```c++
char* getMemroy(){
    char* p = (char*)malloc(30);
    return p;
}
int main(){
    char* p = getMemory();	// 未释放内存
    return 0;
}
```

- （==浅拷贝==）未定义拷贝构造函数，未重载赋值运算符，两次释放相同内存
  - 类中包含指针变量，但默认拷贝构造函数、赋值运算符进行浅拷贝，两个指针对象指向同一个内存空间，操作、释放都会影响另一个
- （==虚函数多态==）没有将基类析构函数定义为虚函数 
  - 基类指针指向派生类的对象，调用析构函数时
    - 如果析构函数是虚函数，调用派生类的析构函数、自动调用基类的析构函数，释放所有内存
    - 如果析构函数不是虚函数，调用基类的析构函数，派生类内存空间没有被释放

###### 判断、定位内存泄漏的方法

Linux系统下，可以使用valgrind、mtrace等内存泄漏检测工具。





#### 内存的分配方式

- 在栈上分配：
  - 临时变量、局部变量、函数参数、函数返回地址
  - 函数结束时自动释放
  - 栈内存的分配运算内置于处理器的指令集中，效率高，但容量小
  - 先进后出，没有碎片
  - 从高地址到低地址
- 在堆上分配：
  - 程序员手动申请
  - 使用new/delete、malloc/free管理，分配、释放灵活
  - 一般由保存语言实现，效率低，容量大
  - 有碎片
  - 从低地址到高地址
- 在数据区分配
  - 常量存储区
    - 常量、文字常量等，不可修改
  - 全局/静态区
    - 全局变量，静态变量等
    - 编译期间分配内存，在整个程序的运行期间都存在
- 在代码区分配
  - 存储二进制代码





#### 静态内存分配，动态内存分配

- 静态内存分配 `int a[10];`
  - 由编译器控制
  - 在编译时期完成，不占用CPU资源
  - 在栈上分配
  - 不需要指针、引用类型的支持
  - 按计划分配，在编译期计算好，确定内存块大小
  - 运行效率高
- 动态内存分配 `malloc` `new`
  - 由程序员控制
  - 在运行时期完成，分配和释放都要占用CPU资源
  - 在堆上分配
  - 需要指针、引用等类型支持
  - 按需分配
  - 运行效率低，可能造成内存泄漏





#### 构造函数、析构函数私有化

- 不想让外面的用户直接构造一个类的对象，而希望用户只能构造这个类的子类，就<u>将类的构造函数/析构函数声明为protected，而将子类的构造函数/析构函数声明为public</u> 

```c++
class A{
protected:
    A(){}
public:
    void test(){ cout << "call A.test()" << endl; }
};


class B : public A{
public:
    B(){}
};

int main(){
    A a;		// 报错，A不允许外部实例化
    B b;		// 允许
    b.test();	// 允许
    return 0;
}
```

- 如果将构造函数/析构函数声明为private，那么只有类的内部能够创建这个类的对象
  - 这个getInstace方法无法被调用，因为调用它代表有一个A类对象被构造出来，但构造函数是private的

```c++
class A{
private:
    A(){}
    ~A(){}
public:
    void getInstance(){ A a; }
};
int main(){
    A a;	// 编译报错
    a.getInstance();
}
```

- 如果getInstance是一个静态函数的话，就可以不需要通过一个对象直接调用了

```c++
class A{
private:
    A():data(10){ cout<< "A()" << endl; }
    ~A(){ cout<< "~A()" << endl; }
public:
    static A& getInstance(){
        static A a;
        return a;
    }
    void Print(){ cout<< data << endl; }
private:
    int data;
};

int main(){
    A& ra = A::getInstance();
    ra.Print();
    return 0;
}
```

- 这就是单例模式：
  - 构造函数私有化
  - 维护类的唯一实例，使用类的私有指针指向这个实例
  - 提供public的静态成员函数，获得这个实例

```c++
// 懒汉式单例，getInstace()在第一次被调用时，才new一个对象返回
class Singleton{
private:
    static Singleton* instance;
private:
    Singleton() {};
	~Singleton() {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
    static Singleton* getInstance(){
        if(instance == nullptr) instance = new Singleton();		// 初始化唯一实例
        return instance;	// 返回指针
    }
};
```

```c++
// 饿汉式单例，单例在程序运行时立刻被初始化
class Singleton{
private:
    static Singleton instance;	// 初始化唯一实例
private:
    Singleton() {};
	~Singleton() {};
	Singleton(const Singleton&);
	Singleton& operator=(const Singleton&);
public:
    static Singleton& getInstance(){
        return instance;	// 返回实例
    }
};
```





#### 如何构造一个类，使其只能在堆或栈上分配内存？

- 只能在堆上分配内存：==析构函数声明为private== 
  - 当在栈上生成对象时，对象会自动析构，也就说析构函数必须可以访问。而堆上生成对象，由于析构时机由程序员控制，所以不一定需要析构函数
  - 需要另外提供一个成员函数，完成delete操作
- 只能在栈上生成对象：==将new和delete重载为private== 





## OS

#### 进程，线程

- 写好的程序可以保存在硬盘中。==<u>被CPU读取到内存中，可执行的程序实例叫进程</u>==
  - 在内存中的每个进程，内部都有一个独立的<u>虚拟地址空间</u>。在进程内的通讯可以根据虚拟地址访问，进程间则需要进程间通讯（IPC），可能需要系统调用。每个进程内部是<u>独立</u>的，每个进程都认为自己独占全部的内存空间。
  - <u>进程是系统进行资源分配和调度的基本单位</u>
- 每个进程加载的程序有一个<u>程序计数器</u>，记录当前程序执行的位置。==一个执行流叫线程==。
  - 每个线程有一个程序计数器，还有寄存器、堆栈等运行时的状态信息
  - 线程间<u>共享</u>地址空间、全局变量、打开的文件信息等

- 理解为：多个线程访问同一个文档，并且需要并行执行
- 线程是并行的最小单位，单CPU划分时间片轮转执行
  - 线程的就绪、运行、阻塞状态。进程状态和线程状态原理相同
  - CPU在内存中为每个线程提供虚拟CPU，每个线程认为自己独占CPU



#### 进程间通信

###### 互斥算法：

两个进程同时读取共享变量，容易发生冲突。设置共享变量，进程间互斥访问共享变量，实现进程间通讯。

- 两个进程同时读取共享变量，这部分代码称为临界区。
- 再设置一个==共享变量表示锁==，避免竞争状态

```c++
// 进程A：
while(turn != 0);
critical_region();
trun = 1;
noncritical_region();

// 进程B：
while(turn != 1);
critical_region();
turn = 0;
noncritical_region();
```

###### 同步算法（生产者消费者问题，有界缓冲区问题）：

一个进程向共享区存数据，称为生产者。另一个进程从共享区取数据，称为消费者。

共享区满，生产者不能传数据；共享区空，消费者不能取数据。

设置==共享变量count，标记共享区数量==。

```c++
// 生产者
item = produce_item();
if(count == N) sleep();
insert_item(item);
count ++;
if(count == 1) wakeup(消费者);

// 消费者
if(count == 0) sleep();
item = remouve_item();
count --;
if(count == N-1) wakeup(生产者);
```

设置共享信号量，所有进程可对其进行down、up操作（PV操作）。设置full=0，empty=共享区大小。

```c++
// 生产者
item = produce_item();
down(&empty);
down(&mutex);
insert_item(item);		// 临界区
up(&mutex);
up(&full);

// 消费者
down(&full);
down(&mutex);
item = remove_item();	// 临界区
up(&mutex);
up(&empty);
consume_item(item);
```



#### CPU调度

CPU需要选择下一个运行的进程（或线程），称为CPU调度问题。

###### 进程的分类

- 计算密集型：长时间占用CPU
- I/O密集型：CPU计算时间短，访问外接设备时间长。（现在CPU越来越快，IO密集型越来越多。NodeJS的出现就是应对这类问题。）

###### 调度策略

- 批处理：
  - <u>先来先服务</u>，运行到阻塞态就换下一个，就绪态则排到末尾
    - 问题：计算密集型线程一直占CPU
  - <u>最短作业优先</u>，最短剩余时间优先
- 轮转调度
  - <u>时间片调度</u>：分时间片，在用户态、内核态之间转换
  - <u>优先级调度</u>，<u>多级反馈队列</u>：优先级高的执行，执行完降一级
- 实时系统



#### 内存管理-地址空间

###### memory hieriarcy

- Cache高速缓存
- 内存，临时存放运行的程序（进程）。对这一部分进行内存管理。
- 磁盘，可以永久存储

###### 地址空间

每个内存单元大小为1Byte，有一个对应的地址，称为物理地址。

内存管理多进程：

- 需要让多个进程独立，程序指令应该是相对地址而不是物理地址
  - 如果用物理地址进行跳转，会跳转到别的进程中
- OS需要进行进程保护
  - 在执行JMP，跳转到别的进程中的语句时，需要进行保护

因此，需要一种存储器抽象，称为地址空间：设置==基址寄存器==、==界限寄存器==，经过==动态重定位==，将<u>相对地址映射为物理地址</u>。

###### 交换swapping

内存大小有限，进程数量很多，放不下。进程需要<u>暂存到磁盘中，并在内存、磁盘中进行交换</u>。

- 内存紧缩：可以腾出大量的连续内存区域，但移动内存需要耗费大量的CPU时间
- 更好地内存管理算法，在下一节

如何管理这些内存

- 位图：划分成小区域，保存每个区域的空闲/占用状态
- 链表： 四个值，保存是否占用、起始位置、结束位置、next
  - 首次适配first fit：找出第一个空闲区
  - 最佳适配best fit：找出大小最合适的空闲区



#### 内存管理-虚拟内存

上一节的基址寄存器、界限寄存器划分地址空间，现在已经不常用了，因为一整个进程可能装不到内存中。

新方法：虚拟内存。<u>把进程切碎，分页管理，一部分页面在内存中</u>

- 当CPU访问的页面不在内存中，则从磁盘中加载对应部分
- 内存不够时，也可以将长期不访问的页面保存到磁盘中

CPU读取的汇编指令，内存管理单元（MMU）将虚拟地址转换成物理地址，然后通过总线找到相应的内存位置。MMU需要记录虚拟地址到物理地址的映射关系，称为==页表==（使用多级页表，增加映射规模）。

页表通常保存于内存中。MMU每次从内存读取页表很慢，因此MMU中暂存最近使用的部分页表项，叫做转换检测缓冲区（相联存储器，TLB）。





## 补充

#### C语言的函数调用过程

- 每个函数调用都会分配函数栈，在栈内划分一部分空间，进行函数执行过程
- 调用前，先把==返回地址压栈==，然后把==当前函数的esp指针（函数的返回地址）压栈==
- 将==函数的参数压栈，顺序从右向左==



#### C++的函数调用过程

- C++如何处理函数返回值
  - <u>生成一个临时变量，把它的引用作为函数参数传入函数内</u> 
- C++的拷贝赋值函数的形参能否进行值传递
  - 拷贝构造函数的参数是一个const引用 `MyClass& (const MyClass& orig);`
  - 不能，如果拷贝构造需要值传递，值传递需要将实参传递给形参，传递的过程中会调用拷贝构造函数，形成递归造成栈溢出















UE4的类

蓝图通信方式

如何实现网络同步，RPC等

unity和ue4





