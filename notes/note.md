##### 占用内存空间

|             单位：Byte             | x86 sizeof() | x64 sizeof() |
| :--------------------------------: | :----------: | :----------: |
|                指针                |      4       |      8       |
|                bool                |      1       |              |
|                char                |      1       |              |
|                int                 |      4       |              |
|                long                |      4       |              |
|             long long              |      8       |              |
|               float                |      4       |              |
|               double               |      8       |              |
|                enum                |      4       |              |
|              空struct              |      1       |              |
|     struct{int,int,char,char}      |      12      |              |
|   struct{double, int, int, char}   |      24      |              |
| struct{int, long long, int, char*} |   32(4848)   |   24(4844)   |
| struct{int, int, long long, char*} |   24(4488)   |   24(4484)   |

###### 整型

- 一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节（Byte）一样
- 其它字符类型用于扩展字符集，wchar_t确保可以存放机器最大扩展字符集中的任意一个字符，char16_t和char32_t为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）
- 除了bool和扩充的char类型，其他整型可以分为带符号的和无符号的两种，加上unsigned的无符号整型所有bit都用来表示值，所以无符号整型只能表示≥0的值

###### 机器实现

- 可寻址最小内存块：字节（byte），存储的基本单元：字（word）
- x32，x64指的都是字长。在32位机器：1word=4byte=32bit，在64位机器：1word=8byte=64bit
- 计算机将每个字节（byte）跟一个地址关联起来。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据占的地址数，以及如何解释这些地址的内容

###### 浮点型

- 通常，float以1个字（32bit）表示，double以2个字（64bit）表示，long double以3或4个字表示（96或128bit）。
- 通常，float和double分别有7和16个有效位，long double则常用于有特殊浮点要求的硬件，精度跟具体实现有关。






##### struct

结构体在声明时不会开辟空间，在结构体实例化变量时再开辟空间。

###### 给struct中的静态数组赋值

```c++
struct MyStruct{
    char str[100];
    int size;
}

int main(){
    MyStruct mystruct1;
    MyStruct mystruct2;
    MyStruct mystruct3;

    // strcpy的第二个参数是const char*类型，适用于把常量区的数组拷贝给struct
    strcpy(mystruct1.str, "helloworld");

    char* a = (char*)"helloworld";
    strcpy(mystruct2.str, a);

    // 对于栈区的数组拷贝给struct，需要手动赋值
    char str_stack[6] = { 'h', 'e', 'l', 'l', 'o', '\0' };
    for (int i = 0;i < 6;i++)
    {
        mystruct3.str[i] = str_stack[i];
    }

    printf("%s, %d\n", mystruct1.str, mystruct1.size);
    printf("%s, %d\n", mystruct2.str, mystruct2.size);
    printf("%s, %d\n", mystruct3.str, mystruct3.size);
    return 0;
}
```

###### 



##### struct内存对齐

https://www.cnblogs.com/alantu2018/p/8460761.html

```c++
struct ss0{  
    char a[15]; //占15个字节，从0开始偏移，所以下面的int是从15开始偏移  
    int x;//偏移量 0x15+1=16  
}s1;  
cout<<sizeof(s1)<<endl; //结果为20字节  

struct ss1    
{  
    char a[15]; // 0-15
    int x; //偏移量 16字节,16-20
    char b; //偏移量 21字节,20-21  
}s2; //结果为21字节，按最大基本类型对齐，补充到24字节  
cout<<sizeof(s2)<<endl; //结果为24字节  

struct  ss2  
{  
    char a[15];  // 0-15
    int x;  // 16-20
    double b; // 24-32
    char c; // 32-33
}s3;//共33字节,按最大基本类型对齐，补充到40字节（整除8）  
cout<<sizeof(s3)<<endl; //结果为40字节


#pragma pack(push)  
#pragma pack(2)  
struct  
{  
    char a; //偏移0，1字节,0-1
    struct ss0 b; // 偏移1+1=2,20字节,2-22
    char f; //偏移22,1字节,22-23
    struct ss1 c;//偏移23+1,24字节,24-48
    char g;//偏移48,1字节,48-49
    struct ss2 d;//偏移49+1,40字节,50-90
    char e;//偏移90,1字节,90-91
}s7;//共91字节，不能整除2，所以补充到92字节  
cout<<"here:"<<sizeof(s7)<<endl;  
#pragma pack(pop)  
```



```c++
struct A  
{  
public:  
    int i;  //偏移0；4字节，0-4
    union U  
    {  
        char buff[13];  
        double i;  
    }u; //偏移4，不能整除sizeof(double)，所以偏移需要补充到8；16字节，8-24 
  
    void foo(){}      
    typedef char* (*f)(void*);  
    char d;//偏移24；大小1字节，24-25
    enum{red , green, blue}color;//偏移25，补充到28；大小4字节，28-32 
    char e;//偏移32；大小1字节，32-33
}a;//大小33字节，不能整除sizeof(double)，补充到40字节
```

- 目的：提高内存的访问效率。如intel 32位CPU，每个总线周期都是从偶地址开始读内存，如果数据存放地址不是从偶数开始，则可能出现两个总线周期才能读取到想要的数据。
  - 数据占用内存的大小取决于数据本身的大小和其字节对齐方式，所谓对齐方式即数据在内存中存储地址的起始偏移应该满足的一个条件。比如说，一个int数据占用4个字节，如果该数据 的偏移是0x00000003，那么CPU就要先取1B、再取2B、最后取1B，三次取数据组合成一个int类型。
  - 为什么不能取一次1B，然后再取一个3B？这个问题从组成原理的角度考虑。32位机器上有4个32位的通用数据寄存器：EAX，EBX，ECX，EDX。每个通用寄存器的低16位又可以单独使用，叫做AX，BX，CX，DX。最后，这四个16位寄存器又可以分成8个独立的8位寄存器：AH、AL等。因此，CPU取数据时或者是一个字节AH或者AL等，或者是两个字节AX，BX等，或者是4个字节EAX，EBX等，而没法一次取三个字节的数据。
  - 如果该int数据的偏移是0x00000002，那么CPU就可以先取一个short，然后再取一个short，两次取值完成一个 int型数据的组合。但是如果偏移是0x00000004，正好是4字节对齐的，那么CPU就可以一次取出这个int类型的数据。所以，为了提高取值速度，一般编译器都会优化数据对齐方式。
- 内存对齐的规则：
  - 数据成员对齐，“偏移”：每个成员的起始位置都能被其中最宽大小整除，每个变量相对于起始位置的偏移，都能被自身大小整除
    - 比如struct中有union{char[13], double}，则union的起始位置必须被8（double的大小）整除
    - 有#pragma pack：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后<u>每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行</u> 
  - 整体对齐，“补齐”：结构体总体大小能被最宽的成员大小整除，不能则在后面补充字节
    - 有#pragma pack：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，<u>对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行</u> 
  - 如果有 `#pragma pack(n)`，且n比按照数据类型得到的对其方式小，则不按照最大元素的倍数偏移，而是按照n的倍数偏移；union等也按照n的倍数取大小
- struct中包含其他复合结构
  - enum一般占4个字节
  - union中各成员占用的内存从同一地址开始，占自己元素的最小公倍数的大小
    - union{char [13], int}正常是16字节（考虑到是int长度的倍数）；如果有#pragma pack 2，扩充时不是按照4字节的倍数来算，而是按照2的倍数来算。最终得到大小为14字节
  - struct和class在C++中其实是一样的，struct也可以有构造函数，析构函数，成员函数和 （private、protected、public）继承。两者的区别在于class默认的成员类型是private，而struct为public。 class默认的继承方式为private，而struct为public。其实核心是struct是数据聚集起来，便于人访问，所以默认的是 public，而class是封装，不让人访问，所以是private。
  - struct或class中定义的<u>成员函数和构造和析构函数不占整体的空间</u>。如果有虚函数的话，会有<u>4个字节的地址存放虚函数表的地址</u>。
  - 类或结构体的<u>静态成员变量不占用结构体或类的空间</u>，也就是说sizeof出来的大小跟静态成员变量的大小无关。在最后补齐字节的时候，也与静态成员变量无关。
    - <u>类或结构体的静态成员变量存储在全局/静态存储区</u>，而类或结构体本身存储在栈上，两者在内存占用上没有关系



##### 堆区和栈区

###### 内存四区：

- ==代码区code==：由操作系统管理，<u>存储二进制代码</u>。可以在栈区存储函数指针，对代码区的代码进行操作。
- ==堆区heap==：<u>由程序员手动分配、释放</u>，程序结束时可能由OS回收。malloc/free，new/delete等。<u>分配方式类似于链表</u>。
- ==栈区stack==：<u>由编译器自动分配释放</u>，<u>存放==函数的参数、局部变量==等</u>
- 数据区，程序结束后由OS释放
  - ==静态全局区static==：存储全局变量和静态变量，C语言按照是否初始化再细分（C++不再分）
    - 凡是有static定义的变量的生命周期就是整个程序的生命周期，直到程序退出，静态变量所占据的内存才会被释放
  - ==文字常量区==：存储常量字符串

###### 应用：

- 写程序的时候，用new、malloc分配的变量放在堆中，但返回的指针变量放在栈中。如果在一个子函数中new了一个变量，但函数返回时，没有保存new返回的指针，也没有delete，就会发生内存泄漏。
- 写程序用到最多的是栈内存，每一个临时变量、new返回的指针、递归函数中的变量都存放在栈中。
- 一般来说，堆从低地址向高地址扩充（因为由程序员读写，比较合乎人类常识），而栈从高地址向低地址增长。（听说Windows和Linux是相反的）

###### 堆和栈的区别

- 管理方式：栈由编译器自动管理；堆由程序员手动管理
- 空间大小：堆很大（32位下4G）；栈很小（VC6下1M）
- 碎片问题：堆由new/delete会产生内存空间的不连续，使程序效率降低；栈是先进后出的队列，不可能从中间出栈
- 生长方向：堆向内存地址增大的方向生长；栈向内存地址减小的方向生长
- 分配方式：堆是动态分配的；栈可以静态分配（如编译器自动分配局部变量），也可以由malloc动态分配
- 分配效率：计算机底层有专门的寄存器存放栈的地址，有专门的压栈出栈指令，使得栈的效率高；堆由C/C++函数库提供，分配内存等机制更复杂，效率低

###### 例零（基本概念）：

```c++
int a = 0;	// 全局（静态）区，初始化区
char* p1;	// 全局（静态）区，未初始化区

int main(){
	int b;	// 栈区
	char s[] = "abc";	// 栈区
	char* p2;	// 栈区
	char* p3 = "123456";	// “123456”在文字常量区，p3在栈区
	
	static int c = 0;	// 全局（静态）区，初始化区
	p1 = (char*)malloc(10);	// 在堆区开辟空间，地址存在p1
	p2 = (char*)malloc(20);	// 在堆区开辟空间
	strcpy(p3, "123456");	// “123456”跟之前是同一个对象，在文字常量区
}
```



###### 例一（栈区）：

```c++
char* pMem1(){
	char* p1 = "helloworld";		
    // “helloworld”：全局区，存储文字常量
    // p1：栈区，8字节的指针，存储全局区常量的地址
    return p1;
}
char* pMem2(){
	char* p2 = "helloworld";
    // 全局区不再新开辟空间，p2存储之前的文字常量的地址
	return p2;
}

int main(){
    char* p1 = pMem1();
    // p1：栈区，把函数中p1存的值复制过来
    // 函数调用完毕，栈区上pMem1()函数开辟的空间销毁
    // 函数调用完毕，全局区存的字符串没有销毁
    
    char* p2 = pMem2();
    // p2：栈区，存全局区相同字符串的地址
    
    printf("p1=%s, p1=%p\n", p1, p1);
    printf("p2=%s, p2=%p\n", p2, p2);
    // 输出：可以正常打印字符串
    // 输出：p1和p2指向的字符串、存储的地址都完全相同
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\2.png" alt="70" style="zoom:67%;" />

###### 例二（栈区）：

```c++
char* p_stack(){
    char str[100] = "helloworld";
    return str;
}
int main(){
    char* p = p_stack();
    print("p=%s", p);
    // 输出：不能正常打印字符串
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\3.png" alt="70" style="zoom:67%;" />



两个例子都是在全局区上开辟空间存储文字常量。

- 例一使<u>用指针（栈区）存储文字常量区的地址</u>，并返回给main函数（栈区），因此在函数中的指针销毁后依然能正常读取全局区的常量。
- 例二<u>使用数组（栈区）存储文字常量的值</u>，将数组的地址返回给main函数，但函数结束后栈区的数组被释放了，因此main函数无法获得栈区存储的字符串。
- 问题的核心：<u>函数结束后，栈区会自动释放，全局区不会自动释放</u>。

因此，在栈区开辟数组有风险。类似操作可以<u>转移到堆上</u>，因为堆区是由程序员手动管理。

###### 例三（堆区）：

```c++
char* p_heap(){
    char* temp = (char*) malloc(100);	// 在堆上开辟内存空间
    strcpy(temp, "helloworld");
    return temp;
}
int main(){
    char* p = p_heap();		// p_heap函数的栈区空间被回收，但栈区的p存储了堆区的地址
    printf("%s\n", p);
    free(p);	// 把p跟堆区的映射解除。不会清空堆区数据，而是告诉OS这部分内存可用
    return 0;
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\4.png" alt="70" style="zoom:67%;" />

###### 例四（结构体）：

```c++
struct MyStruct{
    char c[100];
    int i;
}

// 静态结构体数组，在栈上分配空间
MyStruct m1[3] = { {"hello", 10}, {"world", 10}, {"!", 3} };

// 动态结构体数组，在堆上分配空间，在栈上声明指针指向这个空间
MyStruct *m2 = (MyStruct*)malloc(3 * sizeof(MyStruct));
for(i...){
    strcpy(m2[i].c, "...");
    m2[i].i = ...;
}
free(m2);
```







##### 虚函数



##### 位、字节、地址

###### 概念

- 位：最小的<u>存储单位</u>是bit，存储一个二进制位
- 字节：以8个bit组成一个Byte，作为<u>存储单元</u>，是支持计算机存、取数据的最小单位
- 地址：变量占用空间的起始地址，在分配时决定，之后不再改变、直到变量撤销。地址值是一个常量

###### 使用

```c++
int a;
int* p = &a;
a = 1;
// &a = 0x23;
```

- int* 是一种地址类型，p=0x23，*p=1。



##### 数组指针、指针数组

https://www.cnblogs.com/mq0036/p/3382732.html

- 指针数组：<u>存储指针的数组</u>。是一个==数组==，数组的元素都是指针。
  - 长度：指针长度（系统字长） * 数组元素个数
  - `int* p1[10]` ：p1是数组，存的是 int* 地址类型，也就是指针组成的数组

- 数组指针：<u>指向数组的指针</u>。是一个==指针==，指向一个数组。
  - 长度：指针长度（系统字长）
  -  `int (*p2)[10]` ：p2是指针，指向 int[10] 的数组

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\1.png" alt="70" style="zoom:67%;" />

###### 使用

```c++
int a[3][4];
int (*p)[4]; 	// 定义数组指针，每个指针指向 int[4] 的数组
p = a;			// 将a的首地址赋给p，p指向
p++;			// 现在p指向行a[1][]
```









##### a和&a

```c++
int a[10];
int (*p)[10] = &a;
```

- a：
  - a是数组名，也是数组的首元素地址。
  - (a+1)表示地址a加上一个int类型的大小，如果`a = 0x01`，则`(a+1) = 0x05`，`*(a+1) = a[1]`。
- &a：
  - &a是数组的指针（数组指针），类型为 int(*)[10]



##### static

当一个全局变量在.h头文件中，被多个.cpp文件引用时，编译不会出错，但会导致“符号被多重定义”，需加上==static==，使其变为内部链接，变成多个同名不同义的定义。

static：静态变量。函数内的static变量会在程序执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁。在此期间，函数执行结束后也不会对它有影响（不受函数生命周期的限制）。

#####  

##### 程序的堆栈空间

- stack：系统统一分配，空间小。在编译期，对变量和函数的分配在栈上进行
- heap：用malloc函数手动分配，地址空间大



##### const

const用来定义值不能改变的变量，const变量一旦创建就不能再变化，所以const对象必须初始化。

###### 指针常量、常量指针

从右向左看，*和const按顺序读就是类型的名称：

- `int* const p;` p是常量，类型是int*地址类型。<u>常量指针</u>。
- `int const* p;` p是指针，是常量，指向int。<u>指针常量</u>。
- `const int* p;` p是指针，指向int，是常量。<u>指针常量</u>。
- 指针常量：普通指针，指向的内容是常量。不能通过指针修改内容，可以修改指针指向的地址。
- 常量指针：指针是常量。不能修改指向的地址，可以通过指针修改内容。
- 常量指针常量：都不能。

```c++
// 指针常量，可以修改指针指向的地址，不能通过指针修改内容。修改内容可以通过指向别的地址。
const int* p1 = &a;

int const* p2 = &a;

p1 = &b;  // 正确
p2 = &b;  // 正确

p1 = &c;  // 正确
*p1 = 100;  // 错误
p1 = p2;  // 正确



// 常量指针，可以通过指针修改内容，但不能指向其他地址。
int* const p3 = &a;
p3 = &b;  // 错误
*p3 = 100;  // 正确


// 常量指针常量，不允许修改地址，也不允许修改内容
const int* const p = &a;
*p = 100;  // 错误
p = p2;  // 错误
```







### OS

##### 进程，线程

- 写好的程序可以保存在硬盘中。<u>被CPU读取到内存中，可执行的程序实例叫进程</u>
  - 在内存中的每个进程，内部都有一个独立的虚拟地址空间。在进程内的通讯可以根据虚拟地址访问，进程间则需要进程间通讯（IPC），可能需要系统调用。每个进程内部是<u>独立</u>的，每个进程都认为自己独占全部的内存空间。
  - <u>进程是系统进行资源分配和调度的基本单位</u>
- 每个进程加载的程序有一个程序计数器，记录当前程序执行的位置。一个执行流叫线程。
  - 每个线程有一个程序计数器，还有寄存器、堆栈等运行时的状态信息
  - 线程间<u>共享</u>地址空间、全局变量、打开的文件信息等

- 理解为：多个线程访问同一个文档，并且需要并行执行
- 线程是并行的最小单位，单CPU划分时间片轮转执行
  - 线程的就绪、运行、阻塞状态。进程状态和线程状态原理相同
  - CPU在内存中为每个线程提供虚拟CPU，每个线程认为自己独占CPU



##### 进程间通讯

###### 互斥算法：

两个进程同时读取共享变量，容易发生冲突。设置共享变量，进程间互斥访问共享变量，实现进程间通讯。

- 两个进程同时读取共享变量，这部分代码称为临界区。
- 再设置一个==共享变量表示锁==，避免竞争状态

```c++
// 进程A：
while(turn != 0);
critical_region();
trun = 1;
noncritical_region();

// 进程B：
while(turn != 1);
critical_region();
turn = 0;
noncritical_region();
```

###### 同步算法（生产者消费者问题，有界缓冲区问题）：

一个进程向共享区存数据，称为生产者。另一个进程从共享区取数据，称为消费者。

共享区满，生产者不能传数据；共享区空，消费者不能取数据。

设置==共享变量count，标记共享区数量==。

```c++
// 生产者
item = produce_item();
if(count == N) sleep();
insert_item(item);
count ++;
if(count == 1) wakeup(消费者);

// 消费者
if(count == 0) sleep();
item = remouve_item();
count --;
if(count == N-1) wakeup(生产者);
```

设置共享信号量，所有进程可对其进行down、up操作（PV操作）。设置full=0，empty=共享区大小。

```c++
// 生产者
item = produce_item();
down(&empty);
down(&mutex);
insert_item(item);		// 临界区
up(&mutex);
up(&full);

// 消费者
down(&full);
down(&mutex);
item = remove_item();	// 临界区
up(&mutex);
up(&empty);
consume_item(item);
```



##### CPU调度

CPU需要选择下一个运行的进程（或线程），称为CPU调度问题。

###### 进程的分类

- 计算密集型：长时间占用CPU
- I/O密集型：CPU计算时间短，访问外接设备时间长。（现在CPU越来越快，IO密集型越来越多。NodeJS的出现就是应对这类问题。）

###### 调度策略

- 批处理：
  - 先来先服务，运行到阻塞态就换下一个，就绪态则排到末尾
    - 问题：计算密集型线程一直占CPU
  - 最短作业优先，最短剩余时间优先
- 轮转调度
  - 时间片调度：分时间片，在用户态、内核态之间转换
  - 优先级调度，多级反馈队列：优先级高的执行，执行完降一级
- 实时系统



##### 内存管理-地址空间

###### memory hierarcy

- Cache高速缓存
- 内存，临时存放运行的程序（进程）。对这一部分进行内存管理。
- 磁盘，可以永久存储

###### 地址空间

每个内存单元大小为1Byte，有一个对应的地址，称为物理地址。

内存管理多进程：

- 需要让多个进程独立，程序指令应该是相对地址而不是物理地址
  - 如果用物理地址进行跳转，会跳转到别的进程中
- OS需要进行进程保护
  - 在执行JMP，跳转到别的进程中的语句时，需要进行保护

因此，需要一种存储器抽象，称为地址空间：设置==基址寄存器==、==界限寄存器==，经过==动态重定位==，将相对地址映射为物理地址。

###### 交换swapping

内存大小有限，进程数量很多，放不下需要暂存到磁盘中，并在内存、磁盘中进行交换。

- 内存紧缩：可以腾出大量的连续内存区域，但移动内存需要耗费大量的CPU时间
- 更好地内存管理算法，在下一节

如何管理这些内存

- 位图：划分成小区域，保存每个区域的空闲/占用状态
- 链表： 四个值，保存是否占用、起始位置、结束位置、next
  - 首次适配first fit：找出第一个空闲区
  - 最佳适配best fit：找出大小最合适的空闲区



##### 内存管理-虚拟内存

上一节的基址寄存器、界限寄存器划分地址空间，现在已经不常用了，因为一整个进程可能装不到内存中。

新方法：虚拟内存。<u>把进程切碎，分页管理，一部分页面在内存中</u>

- 当CPU访问的页面不在内存中，则从磁盘中加载对应部分
- 内存不够时，也可以将长期不访问的页面保存到磁盘中

CPU读取的汇编指令，内存管理单元（MMU）将虚拟地址转换成物理地址，然后通过总线找到相应的内存位置。MMU需要记录虚拟地址到物理地址的映射关系，称为页表（使用多级页表，增加映射规模）。

页表通常保存于内存中。MMU每次从内存读取页表很慢，因此MMU中暂存最近使用的部分页表项，叫做转换检测缓冲区（相联存储器，TLB）。