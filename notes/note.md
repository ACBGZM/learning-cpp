基本语法

面向对象

内存管理

STL

C++ 11









#### 内存空间

|             单位：Byte             | x86 sizeof() | x64 sizeof() |
| :--------------------------------: | :----------: | :----------: |
|                指针                |      4       |      8       |
|                bool                |      1       |              |
|                char                |      1       |              |
|                int                 |      4       |              |
|                long                |      4       |              |
|             long long              |      8       |              |
|               float                |      4       |              |
|               double               |      8       |              |
|                enum                |      4       |              |
|              空struct              |      1       |              |
|     struct{int,int,char,char}      |      12      |              |
|   struct{double, int, int, char}   |      24      |              |
| struct{int, long long, int, char*} |   32(4848)   |   24(4844)   |
| struct{int, int, long long, char*} |   24(4488)   |   24(4484)   |

###### 整型

- 一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节（Byte）一样
- 其它字符类型用于扩展字符集，wchar_t确保可以存放机器最大扩展字符集中的任意一个字符，char16_t和char32_t为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）
- 除了bool和扩充的char类型，其他整型可以分为带符号的和无符号的两种，加上unsigned的无符号整型所有bit都用来表示值，所以无符号整型只能表示≥0的值

###### 机器实现

- 可寻址最小内存块：字节（byte），存储的基本单元：字（word）
- x32，x64指的都是字长。在32位机器：1word=4byte=32bit，在64位机器：1word=8byte=64bit
- 计算机将每个字节（byte）跟一个地址关联起来。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据占的地址数，以及如何解释这些地址的内容

###### 浮点型

- 通常，float以1个字（32bit）表示，double以2个字（64bit）表示，long double以3或4个字表示（96或128bit）。
- 通常，float和double分别有7和16个有效位，long double则常用于有特殊浮点要求的硬件，精度跟具体实现有关。





#### 位、字节、地址

###### 概念

- 位：最小的<u>存储单位</u>是bit，存储一个二进制位
- 字节：以8个bit组成一个Byte，作为<u>存储单元</u>，是支持计算机存、取数据的最小单位
- 地址：变量占用空间的起始地址，在分配时决定，之后不再改变、直到变量撤销。地址值是一个常量

###### 使用

```c++
int a;
int* p = &a;
a = 1;
// &a = 0x23;
```

- int* 是一种地址类型，p=0x23，*p=1。

###### 设置 0x67a9 的整型变量的值为 0xaa66

```c++
int* ptr;
ptr = (int*)0x67a9;
*ptr = 0xaa66;
```






#### struct

结构体在声明时不会开辟空间，在结构体实例化变量时再开辟空间。

###### 给struct中的静态数组赋值

```c++
struct MyStruct{
    char str[100];
    int size;
}

int main(){
    MyStruct mystruct1;
    MyStruct mystruct2;
    MyStruct mystruct3;

    // strcpy的第二个参数是const char*类型，适用于把常量区的数组拷贝给struct
    strcpy(mystruct1.str, "helloworld");

    char* a = (char*)"helloworld";
    strcpy(mystruct2.str, a);

    // 对于栈区的数组拷贝给struct，需要手动赋值
    char str_stack[6] = { 'h', 'e', 'l', 'l', 'o', '\0' };
    for (int i = 0;i < 6;i++)
    {
        mystruct3.str[i] = str_stack[i];
    }

    printf("%s, %d\n", mystruct1.str, mystruct1.size);
    printf("%s, %d\n", mystruct2.str, mystruct2.size);
    printf("%s, %d\n", mystruct3.str, mystruct3.size);
    return 0;
}
```





#### struct内存对齐

https://www.cnblogs.com/alantu2018/p/8460761.html

```c++
struct ss0{  
    char a[15]; //占15个字节，从0开始偏移，所以下面的int是从15开始偏移  
    int x;//偏移量 0x15+1=16  
}s1;  
cout<<sizeof(s1)<<endl; //结果为20字节  

struct ss1    
{  
    char a[15]; // 0-15
    int x; //偏移量 16字节,16-20
    char b; //偏移量 21字节,20-21  
}s2; //结果为21字节，按最大基本类型对齐，补充到24字节  
cout<<sizeof(s2)<<endl; //结果为24字节  

struct  ss2  
{  
    char a[15];  // 0-15
    int x;  // 16-20
    double b; // 24-32
    char c; // 32-33
}s3;//共33字节,按最大基本类型对齐，补充到40字节（整除8）  
cout<<sizeof(s3)<<endl; //结果为40字节


#pragma pack(push)  
#pragma pack(2)  
struct  
{  
    char a; //偏移0，1字节,0-1
    struct ss0 b; // 偏移1+1=2,20字节,2-22
    char f; //偏移22,1字节,22-23
    struct ss1 c;//偏移23+1,24字节,24-48
    char g;//偏移48,1字节,48-49
    struct ss2 d;//偏移49+1,40字节,50-90
    char e;//偏移90,1字节,90-91
}s7;//共91字节，不能整除2，所以补充到92字节  
cout<<"here:"<<sizeof(s7)<<endl;  
#pragma pack(pop)  
```



```c++
struct A  
{  
public:  
    int i;  //偏移0；4字节，0-4
    union U  
    {  
        char buff[13];  
        double i;  
    }u; //偏移4，不能整除sizeof(double)，所以偏移需要补充到8；16字节，8-24 
  
    void foo(){}      
    typedef char* (*f)(void*);  
    char d;//偏移24；大小1字节，24-25
    enum{red , green, blue}color;//偏移25，补充到28；大小4字节，28-32 
    char e;//偏移32；大小1字节，32-33
}a;//大小33字节，不能整除sizeof(double)，补充到40字节
```

- 目的：提高内存的访问效率。如intel 32位CPU，每个总线周期都是从偶地址开始读内存，如果数据存放地址不是从偶数开始，则可能出现两个总线周期才能读取到想要的数据。
  - 数据占用内存的大小取决于数据本身的大小和其字节对齐方式，所谓对齐方式即数据在内存中存储地址的起始偏移应该满足的一个条件。比如说，一个int数据占用4个字节，如果该数据 的偏移是0x00000003，那么CPU就要先取1B、再取2B、最后取1B，三次取数据组合成一个int类型。
  - 为什么不能取一次1B，然后再取一个3B？这个问题从组成原理的角度考虑。32位机器上有4个32位的通用数据寄存器：EAX，EBX，ECX，EDX。每个通用寄存器的低16位又可以单独使用，叫做AX，BX，CX，DX。最后，这四个16位寄存器又可以分成8个独立的8位寄存器：AH、AL等。因此，CPU取数据时或者是一个字节AH或者AL等，或者是两个字节AX，BX等，或者是4个字节EAX，EBX等，而没法一次取三个字节的数据。
  - 如果该int数据的偏移是0x00000002，那么CPU就可以先取一个short，然后再取一个short，两次取值完成一个 int型数据的组合。但是如果偏移是0x00000004，正好是4字节对齐的，那么CPU就可以一次取出这个int类型的数据。所以，为了提高取值速度，一般编译器都会优化数据对齐方式。
- 内存对齐的规则：
  - 数据成员对齐，“偏移”：每个成员的起始位置都能被其中最宽大小整除，每个变量相对于起始位置的偏移，都能被自身大小整除
    - 比如struct中有union{char[13], double}，则union的起始位置必须被8（double的大小）整除
    - 有#pragma pack：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后<u>每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行</u> 
  - 整体对齐，“补齐”：结构体总体大小能被最宽的成员大小整除，不能则在后面补充字节
    - 有#pragma pack：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，<u>对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行</u> 
  - 如果有 `#pragma pack(n)`，且n比按照数据类型得到的对其方式小，则不按照最大元素的倍数偏移，而是按照n的倍数偏移；union等也按照n的倍数取大小
- struct中包含其他复合结构
  - enum一般占4个字节
  - union中各成员占用的内存从同一地址开始，占自己元素的最小公倍数的大小
    - union{char [13], int}正常是16字节（考虑到是int长度的倍数）；如果有#pragma pack 2，扩充时不是按照4字节的倍数来算，而是按照2的倍数来算。最终得到大小为14字节
  - struct和class在C++中其实是一样的，struct也可以有构造函数，析构函数，成员函数和 （private、protected、public）继承。两者的区别在于class默认的成员类型是private，而struct为public。 class默认的继承方式为private，而struct为public。其实核心是struct是数据聚集起来，便于人访问，所以默认的是 public，而class是封装，不让人访问，所以是private。
  - struct或class中定义的<u>成员函数和构造和析构函数不占整体的空间</u>。如果有虚函数的话，会有<u>4个字节的地址存放虚函数表的地址</u>。
  - 类或结构体的<u>静态成员变量不占用结构体或类的空间</u>，也就是说sizeof出来的大小跟静态成员变量的大小无关。在最后补齐字节的时候，也与静态成员变量无关。
    - <u>类或结构体的静态成员变量存储在全局/静态存储区</u>，而类或结构体本身存储在栈上，两者在内存占用上没有关系





#### 堆区和栈区

###### 内存四区：

- ==代码区code==：由操作系统管理，<u>存储二进制代码</u>。可以在栈区存储函数指针，对代码区的代码进行操作。
- ==堆区heap==：<u>由程序员手动分配、释放</u>，程序结束时可能由OS回收。malloc/free，new/delete等。<u>分配方式类似于链表</u>。
- ==栈区stack==：<u>由编译器自动分配释放</u>，<u>存放==函数的参数、局部变量==等</u>
- 数据区，程序结束后由OS释放
  - ==静态全局区static==：存储全局变量和静态变量，C语言按照是否初始化再细分（C++不再分）
    - 凡是有static定义的变量的生命周期就是整个程序的生命周期，直到程序退出，静态变量所占据的内存才会被释放
  - ==文字常量区==：存储常量字符串

###### 应用：

- 写程序的时候，用new、malloc分配的变量放在堆中，但返回的指针变量放在栈中。如果在一个子函数中new了一个变量，但函数返回时，没有保存new返回的指针，也没有delete，就会发生内存泄漏。
- 写程序用到最多的是栈内存，每一个临时变量、new返回的指针、递归函数中的变量都存放在栈中。
- 一般来说，堆从低地址向高地址扩充（因为由程序员读写，比较合乎人类常识），而栈从高地址向低地址增长。（听说Windows和Linux是相反的）

###### 堆和栈的区别

- 管理方式：栈由编译器自动管理；堆由程序员手动管理
- 空间大小：堆很大（32位下4G）；栈很小（VC6下1M）
- 碎片问题：堆由new/delete会产生内存空间的不连续，使程序效率降低；栈是先进后出的队列，不可能从中间出栈
- 生长方向：堆向内存地址增大的方向生长；栈向内存地址减小的方向生长
- 分配方式：堆是动态分配的；栈可以静态分配（如编译器自动分配局部变量），也可以由malloc动态分配
- 分配效率：计算机底层有专门的寄存器存放栈的地址，有专门的压栈出栈指令，使得栈的效率高；堆由C/C++函数库提供，分配内存等机制更复杂，效率低

###### 例零（基本概念）：

```c++
int a = 0;	// 全局（静态）区，初始化区
char* p1;	// 全局（静态）区，未初始化区

int main(){
	int b;	// 栈区
	char s[] = "abc";	// 栈区
	char* p2;	// 栈区
	char* p3 = "123456";	// “123456”在文字常量区，p3在栈区
	
	static int c = 0;	// 全局（静态）区，初始化区
	p1 = (char*)malloc(10);	// 在堆区开辟空间，地址存在p1
	p2 = (char*)malloc(20);	// 在堆区开辟空间
	strcpy(p3, "123456");	// “123456”跟之前是同一个对象，在文字常量区
}
```

###### 例一（栈区）：

```c++
char* pMem1(){
	char* p1 = "helloworld";		
    // “helloworld”：全局区，存储文字常量
    // p1：栈区，8字节的指针，存储全局区常量的地址
    return p1;
}
char* pMem2(){
	char* p2 = "helloworld";
    // 全局区不再新开辟空间，p2存储之前的文字常量的地址
	return p2;
}

int main(){
    char* p1 = pMem1();
    // p1：栈区，把函数中p1存的值复制过来
    // 函数调用完毕，栈区上pMem1()函数开辟的空间销毁
    // 函数调用完毕，全局区存的字符串没有销毁
    
    char* p2 = pMem2();
    // p2：栈区，存全局区相同字符串的地址
    
    printf("p1=%s, p1=%p\n", p1, p1);
    printf("p2=%s, p2=%p\n", p2, p2);
    // 输出：可以正常打印字符串
    // 输出：p1和p2指向的字符串、存储的地址都完全相同
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\2.png" alt="70" style="zoom:67%;" />

###### 例二（栈区）：

```c++
char* p_stack(){
    char str[100] = "helloworld";
    return str;
}
int main(){
    char* p = p_stack();
    print("p=%s", p);
    // 输出：不能正常打印字符串
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\3.png" alt="70" style="zoom:67%;" />



两个例子都是在全局区上开辟空间存储文字常量。

- 例一使<u>用指针（栈区）存储文字常量区的地址</u>，并返回给main函数（栈区），因此在函数中的指针销毁后依然能正常读取全局区的常量。
- 例二<u>使用数组（栈区）存储文字常量的值</u>，将数组的地址返回给main函数，但函数结束后栈区的数组被释放了，因此main函数无法获得栈区存储的字符串。
- 问题的核心：<u>函数结束后，栈区会自动释放，全局区不会自动释放</u>。

因此，在栈区开辟数组有风险。类似操作可以<u>转移到堆上</u>，因为堆区是由程序员手动管理。

###### 例三（堆区）：

```c++
char* p_heap(){
    char* temp = (char*) malloc(100);	// 在堆上开辟内存空间
    strcpy(temp, "helloworld");
    return temp;
}
int main(){
    char* p = p_heap();		// p_heap函数的栈区空间被回收，但栈区的p存储了堆区的地址
    printf("%s\n", p);
    free(p);	// 把p跟堆区的映射解除。不会清空堆区数据，而是告诉OS这部分内存可用
    return 0;
}
```

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\4.png" alt="70" style="zoom:67%;" />

###### 例四（结构体）：

```c++
struct MyStruct{
    char c[100];
    int i;
}

// 静态结构体数组，在栈上分配空间
MyStruct m1[3] = { {"hello", 10}, {"world", 10}, {"!", 3} };

// 动态结构体数组，在堆上分配空间，在栈上声明指针指向这个空间
MyStruct *m2 = (MyStruct*)malloc(3 * sizeof(MyStruct));
for(i...){
    strcpy(m2[i].c, "...");
    m2[i].i = ...;
}
free(m2);
```





#### 内存分布

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\5.png" alt="70" style="zoom:67%;" />





#### 虚函数

C++中的虚函数的作用主要是实现多态。<u>用父类的指针指向子类的实例，然后通过父类的指针调用子类的成员函数</u>。

```c++
// 虚函数
class A{
public:
	virtual void foo(){
        cout<<"A::foo() is called"<<endl;
    }   
};
class B:public A{
public:
	void foo(){
        cout<<"B::foo() is called"<<endl;
    }   
};
int main(){
    A* a = new B();
    a->foo();		// 在这里，使用父类A的指针指向子类B的对象，调用子类B的函数
    // 输出结果：B::foo() is called
    return 0;
}
```

###### 纯虚函数

纯虚函数在基类中声明但不定义，要求任何派生类定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 `=0`。

```c++
virtua void funciton() = 0;
```

纯虚函数引入的原因是：

- 为了方便使用多态特性，需要在基类中定义虚函数。

- 很多情况下，基类本身生成对象是不合理的。例如动物可以派生出猫狗类，但动物类本身生成对象不合常理。

含有纯虚函数的类称为抽象类，它不能生成对象。用户不能创建类的实例，只能创建它的派生类的实例。

纯虚函数让所有派生类的对象都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个默认实现。”你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它。“

###### 虚函数，纯虚函数

<u>定义一个函数为虚函数，不代表函数不被实现</u>（如上面的代码实现了foo()），而是为了允许使用父类的指针来调用子类的这个函数。

<u>定义一个函数为纯虚函数，才代表函数没有被实现</u>，是为了实现一个接口，起到规范的作用，使继承这个类的程序员必须实现这个函数。

###### 抽象类

- 定义：带有纯虚函数的类称为抽象类
- 作用：将操作作为接口，组织在一个继承层次结构中，为派生类提供一个公共的根，要求派生类必须实现在基类中的接口
- <u>抽象类是不能定义对象的</u>
- 使用时注意：抽象类只能作为基类使用。如果子类没有重新定义（全部的）纯虚函数，那这个子类仍然是一个抽象类，依然不能定义对象

###### 实现注意

- 虚函数是C++中实现多态的机制，核心理念就是通过基类访问派生类的函数
- 在有动态分配堆内存时，析构函数必须是虚函数，但没必要是纯虚函数
- 析构函数应当是虚函数，因此指针指向子类对象，调用子类析构函数时，会自动调用基类析构函数
  - 创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数
  - 而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数

###### 构造函数，析构函数

- ==构造函数不能是虚函数==：<u>虚函数的调用需要虚函数表指针vptr，该指针存放在==对象的内存空间==中</u>。若构造函数是虚函数，那么由于对象未创建，没有内存空间，无法获得虚函数表地址用来调用虚函数——构造函数
- 基类的析构函数最好是虚函数：虚函数目的是用基类指针调用子类方法
  - 如果基类的析构函数不是虚函数，会调用基类的析构函数，只释放了派生类中的基类部分，造成内存泄漏
  - 如果基类的析构函数是虚函数，会先调用派生类的析构函数，然后调用基类的析构函数

```c++
class A{}
class B:public A{}

// 如果A的析构函数不是虚函数，delete p只调用A的析构函数
// 如果A的析构函数是虚函数，delete p先调用B的析构函数、再调用A的析构函数
A* p = new B;
delete p;

// p是B的对象，也是先调用B的析构函数、再调用A的析构函数
B* p = new B;
delete p;
```

###### vptr

若类中包含虚函数，则编译器会在类实例化对象时，在对象中加入vptr指针，它指向一个虚函数表。

<u>子类和父类分别有自己的虚函数表</u>，所以使用父类指针调用类的虚函数时，会根据实际的对象是子类对象还是父类对象，来实现虚函数的调用。





#### 右值引用（C++ 11）

右值引用：以引用传递（而非值传递）的方式使用C++右值。

###### 左值，右值

- 左值：lvalue（**locator** value），意为<u>存储在内存中、有明确存储地址（可寻址）的数据</u>
- 右值：rvalue（**read** value），意为<u>可提供数据值的数据，不一定可寻址（如存储与寄存器中的数据）</u>

判断表达式是左值还是右值的方法：

- ==可位于=左侧的表达式是左值，只能位于=右侧的表达式是右值== 
  - `int a = 5;` 5是右值，a是左值
  - C++的左值可作右值。`a = b; `
- ==有名称、可获取到存储地址的表达式是左值；反之是右值== 
  - &a &b可以获得地址，a和b是左值
  - 5是字面常量，没有名称、无法获取存储地址（字面常量通常存储于寄存器，或和代码存储在一起），因此是右值

###### 右值引用

在C++ 98/03，不支持为右值创建非常量的左值引用。（常量左值引用可以操作右值）

```c++
int num = 10;
int& b = num;	// 正确，为num创建左值引用
int& c = 10;	// 错误，无法创建右值 10 的引用

const int& bb = num;	// 正确
const int& cc = 10;		// 正确
```

右值往往没有名称，开发中我们可能需要对右值进行修改，左值引用是不行的。因此，C++ 11引入了右值引用。

- 和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化
- 右值引用可以对右值进行修改
- 语法上支持常量右值引用，但无实际用处

```c++
int num = 10;

int&& a = num;	// 错误，右值引用不能初始化为左值
int&& a = 10;	// 创建右值引用

a = 100;	// 修改右值

const int&& aa = 10;	// 常量右值引用，没有实际用处
```

###### 应用

右值引用主要是用在两处：<u>移动语义、完美转发</u>。

###### std::move()

utility中提供一个函数：`std::move`，功能是将一个左值强制转换成右值引用。避免复制，而是转移资源控制权。

- https://www.zhihu.com/question/467449795/answer/1961099671
- std::move进行了一种人工的转化，在转化之后，其返回了一个右值。通过使用这个右值，我们可以调用任何重载了使用右值作为形参的版本的函数。这样的函数一般利用了“==避免复制，而是转移资源控制权==”这一理念，从而高效的转移被分配的内存，<u>避免了多次重分配内存带来的性能降低</u>。其代价是，我们必须有意识地遵守一个基本规定，“右值是不可使用的”。在使用了std::move转化出的右值之后，对于原始的对象我们不要对其进行任何的访问、修改，静待它被析构即可。

在unique_ptr的移动中用到。





#### 智能指针（C++ 11）

智能指针的作用是管理一个指针。存在以下情况：申请的空间在函数结束时忘记释放，带来空悬指针问题、造成内存泄漏。

<u>智能指针的作用原理：智能指针本身是一个类，当超出类的作用域时（函数结束时），类自动调用析构函数，析构函数自动释放资源。</u>

智能指针用于动态分配内存，设计思想是将基本类型指针封装为（模板）类对象指针，并在离开作用域时调用析构函数，使用delete删除指针所指向的内存空间。常在多线程程序中运用。

###### 1.unique_ptr

实现独占的概念，==无法进行拷贝构造和拷贝赋值，可以进行移动构造和移动赋值==。

`unique_ptr`拥有对持有对象的唯一所有权。即<u>同一时间两个`unique_ptr`不能同时指向同一个对象</u>。

- `unique_ptr`不能被复制到另一个`unique_ptr`
- `unique_ptr`所持有的对象只能通过转义语义将所有权转移到另一个`unique_ptr`

```c++
std::unique_ptr<A> a1(new A());
std::unique_ptr<A> a2 = a1;	// 错误
std::unique_ptr<A> a3 = std::move(a1);	// 可以，所有权转移后，a1不再拥有任何指针
```

unique_ptr拥有的方法：

- get()：获取其保存的原生指针，尽量不要用
- bool()：判断是否拥有指针
- release()：释放所管理指针的所有权，返回原生指针，并不销毁原生指针
- reset()：释放并销毁原生指针。如果参数为一个新指针，将管理这个新指针

```c++
std::unique_ptr<A> a1(new A());
A* origin_a = a1.get(); 	// 尽量不要暴露原生指针
if(a1){
    // a1 拥有指针
}

std::unique_ptr<A> a2(a1.release());	// 常见用法，转义拥有权
a2.reset(new A());		// 释放、销毁原有对象，持有一个新对象
a2.reset();			// 释放、销毁原有对象，等同于下面写法
a2 = nullptr;		// 释放、销毁原有对象
```

###### 2.shared_ptr

与`unique_ptr`的唯一所有权所不同的是，`shared_ptr` 实现共享拥有的概念。也就是说多个`shared_ptr`可以拥有同一个原生指针的所有权。

`shared_ptr` 通过引用计数的方式管理指针，当引用计数为 0 时会销毁拥有的原生对象。

###### 3.weak_ptr

`weak_ptr` 解决`shared_ptr` 相互引用时，两个指针的引用计数不清零、导致死锁的问题。

`weak_ptr` 是对对象的一种弱引用

- 是一个弱指针，本身不能直接调用原生指针的方法。如果想要使用原生指针的方法，需要将其先转换为一个`shared_ptr`
- 可以绑定到 `shared_ptr` ，但不会增加对象的引用计数

###### 实际使用

- `unique_ptr`独占对象的所有权，由于没有引用计数，因此性能较好
- `shared_ptr`共享对象的所有权，但性能略差
- `weak_ptr`配合`shared_ptr`，解决循环引用的问题





#### 四种智能指针再理解

###### 1. auto_ptr

auto_ptr采用所有权模式：

```c++
auto_ptr<string> p1(new string("HelloWorld!"));
auto_ptr<string> p2;
p2 = p1;	// auto_ptr不会报错
```

p2剥夺了p1的所有权，但当程序访问p1时会报错。auto_ptr存在潜在的内存崩溃问题，在C++11中已被弃用。



###### 2. unique_ptr

unique_ptr 替换 auto_ptr，实现独占的概念，保证同一时间只有一个智能指针可以指向该对象，对于避免资源泄露（比如new创建对象后忘记delete）特别有用。

unique_ptr采用所有权模式：

```c++
unique_ptr<string> p1(new string("HelloWorld!"));
unique_ptr<string> p2;
p2 = p1;	// 此时报错
```

在直接转移所有权时，编译器报错，避免了p1不再指向有效数据的不安全问题。



另外，当程序试图将一个 unique_ptr 赋值给另一个时 ，如果源 unique_ptr 是一个临时右值，编译器就允许；如果源 unique_ptr 将存在一段时间，编译器就禁止这么做。

```c++
unique_ptr<string> p1(new string("HelloWorld!"));
unique_ptr<string> p2;
p2 = p1;	// 此时报错，p1作为对象存在内存

unique_ptr<string> p3;
p3 = unique_ptr<string>(new string("HelloWorld! rvalue"));	// 不报错，用临时右值给p3赋值
```

- `p2 = p1;` 留下悬挂指针p1，编译器禁止这样做
- `p3 = unique_ptr<string>(new string("HelloWorld! rvalue"));` 不会留下悬挂指针，因为调用unique_ptr 的构造函数，创建临时变量、转让所有权给p3然后被销毁



执行类似 `p2 = p1` 的操作需要使用==移动语义==：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);	// ps1的控制权转移给ps2，ps1悬空
ps1 = demo("world");	// 通过赋新值，重用ps1
```



###### 3. shared_ptr

shared_ptr实现共享概念，多个智能指针指向相同对象，该对象和相关资源会在”最后一个引用被销毁“时释放。

- 使用==计数机制==来表明资源被几个指针共享，通过成员函数 `use_count()` 查看资源的所有者个数
  - 当调用 `release()` 时，当前指针释放资源所有权，计数减一
  - 计数为0时，资源被释放
- 除了使用new来构造，还可通过传入 auto_ptr、unique_ptr、weak_ptr 来构造



###### 4. weak_ptr

weak_ptr 指向一个 shared_ptr 管理的对象，但不进行内存管理。

- shared_ptr 作为强引用，进行对象的内存管理；<u>weak_ptr 是对象的弱引用</u>，仅提供对象的一个访问手段
  - <u>不能通过 weak_ptr 直接访问对象的方法</u>，需要转换成 shared_ptr
- weak_ptr 只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造， 可以跟 shared_ptr 相互转换
  - shared_ptr 直接赋值给 weak_ptr
  - weak_ptr 通过 `lock()` 来获得 shared_ptr
- weak_ptr 的目的是为了==解决 shared_ptr 互相引用而出现的死锁问题==（计数器永不为0，资源永不释放）

```c++
class A{
public:
    shared_ptr<B> pa_;
    ~A(){ cout<<"delete A"<<endl; }
}

class B{
public:
    shared_ptr<A> pa_;
    ~B(){ cout<<"delete B"<<endl; }
}

void fun(){
    shared_ptr<B> pb(new B());
    shared_ptr<A> pa(new A());
    
    // 两个 shared_ptr 相互引用
    pb->pa_ = pa;
    pa->pb_ = pb;
    
    // 发现出现死锁
    cout<<pb.use_count()<<endl;
    cout<<pa.use_count()<<endl;
}


int main(){
    fun();
    return 0;
}
```

此时两个资源的引用计数都为2。跳出函数时各自-1还是不为0，导致资源未释放（A、B的析构函数没被调用）。

把其一改为 weak_ptr，则问题解决。如果把 A 改为 weak_ptr：

- <u>资源B的引用计数为1（A对B是弱引用，不计数），pb析构时B的计数为0，B释放</u> 
- <u>资源A的引用计数为2（B对A是强引用），B释放同时，A的计数-1，析构再-1，A的计数为0，A释放</u> 





#### 数组指针、指针数组

https://www.cnblogs.com/mq0036/p/3382732.html

- 指针数组：<u>存储指针的数组</u>。是一个==数组==，数组的元素都是指针。
  - 长度：指针长度（系统字长） * 数组元素个数
  - `int* p1[10]` ：p1是数组，存的是 int* 地址类型，也就是指针组成的数组

- 数组指针：<u>指向数组的指针</u>。是一个==指针==，指向一个数组。
  - 长度：指针长度（系统字长）
  -  `int (*p2)[10]` ：p2是指针，指向 int[10] 的数组

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\1.png" alt="70" style="zoom:67%;" />

###### 使用

```c++
int a[3][4];
int (*p)[4]; 	// 定义数组指针，每个指针指向 int[4] 的数组
p = a;			// 将a的首地址赋给p，p指向
p++;			// 现在p指向行a[1][]
```





#### a和&a

```c++
int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

int* p1 = a;
int (*p2)[10] = &a;
```

- a：
  - a是数组名，也是数组的首元素地址。
  - (a+1)表示地址a加上一个int类型的大小，如果`a = 0x01`，则`(a+1) = 0x05`，`*(a+1) = a[1]`。
- &a：
  - &a是数组的指针（数组指针），类型为 int(*)[10]
  - 把&a赋值给p，(&a+1)=p+1 指向整个数组结束后的下一个地址





#### C和C++的区别

- C是面向过程语言，C++是面向对象语言
- C使用==malloc/free库函数==管理堆内存，C++使用==new/delete运算符==
- C++引入==引用==的概念
- C++引入==类==的概念
- C++引入==函数重载==的特性
- static
  - C的 static 用来修饰局部静态变量、外部静态变量
  - C++引入类，因此 static 还可修饰静态成员变量、静态成员函数
  - 编程时，static 具有记忆性、全局性的特点，可以使在<u>不同时期调用的函数</u>进行通信，而C++的静态成员变量则可以在<u>多个对象实例之间</u>进行通信、传递信息





#### delete 和 free 的区别

- malloc/free 是==库函数==，new/delete 是==运算符==

- 析构函数不负责释放自己，只负责释放自己分配的子对象
- ==free只释放对象本身的内存，delete要调用析构函数==。析构函数负责释放实现该对象的程序员自己觉得需要释放的其它资源。——这些资源的信息记录在对象本身，所以<u>需要先释放这些资源之后才能释放对象本身的内存</u> 





#### static

static：静态变量。使变量在==静态存储区==分配内存。<u>函数内的static变量会在程序执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁</u>。在此期间，函数执行结束后也不会对它有影响（不受函数生命周期的限制）。<u>生命周期不受影响，但作用域依然有影响</u>。

- static修饰局部变量，生命周期为函数的生命周期，作用域依然为局部作用域
- static修饰全局变量，变量在整个文件中可见
  - 当一个全局变量在.h头文件中，被多个.cpp文件引用时，编译不会出错，但会导致“符号被多重定义”，需加上static，使其变为==内部链接==，变成多个同名不同义的定义。
- static修饰函数，在声明该函数的整个文件中可见，文件外不可见，从而可以在多人协作中避免同名函数冲突
- static修饰类的成员变量：==静态成员变量==。所有对象都只维持一分拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问`Student::num_toal` 
  - <u>静态成员变量不占用对象的内存，也是在静态全局区存放</u>。因此可以直接访问

- static修饰类的成员函数：==静态成员函数==。普通==静态成员函数没有 this 指针==，不知道指向哪个对象，无法访问对象的成员变量，也就是说<u>静态成员函数不能访问普通成员变量，只能访问静态成员变量</u>
  - 在C++中调用类的成员函数，会传递一个this指针，<u>将类的实例化对象的首地址传递给成员函数</u>，函数操作会根据对象首地址计算其成员变量的地址，然后进行操作。然而静态成员变量并不保存在对象的内存布局中，而是保存在数据段中，因而没有必要用到this指针。这使普通函数访问静态成员变量

###### 静态成员变量

```c++
class Student{
public:
    Student(char* name, int age, float score);
    void show();
public:
	static int num_total;	// 静态成员变量，多个对象共享
private:
    char* m_name;
    int m_age;
    float m_score;
}

int Student::num_total = 0;	// 静态成员变量初始化

// 实现构造函数
Student::Student(char* name, int age, float score):m_name(name), m_age(age), m_score(score){
    num_total += 1;
}

void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<"（当前共有"<<m_total<<"名学生）"<<endl;
}

int main(){
    
    // 通过类访问静态成员变量
    Student::num_total = 1;
    
    // 通过对象访问静态成员变量
    Student stu("johnsmith", 19, 83);
    stu.num_total = 2;
    
    // 通过对象指针访问静态成员变量
    Student* pStu = new Student("lihua", 18, 84);
    pStu->num_total =20;
    
    // 创建匿名对象
    (new Student("小明", 15, 90)) -> show();		// 打印第4名
    (new Student("李磊", 16, 80)) -> show();		// 打印第5名
    (new Student("张华", 16, 99)) -> show();		// 打印第6名
    (new Student("王康", 14, 60)) -> show();		// 打印第7名
    // 使用匿名对象无法回收内存，会导致内存泄露，在大型程序中不建议使用。

    return 0;
}
```

###### 静态成员函数

```c++
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:
    // 声明静态成员函数
    static int getTotal();
    static float getPoints();
private:
    // 静态成员变量
    static int m_total;  //总人数
    static float m_points;  //总成绩
private:
    char *m_name;
    int m_age;
    float m_score;
};

int Student::m_total = 0;
float Student::m_points = 0.0;

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    m_total++;
    m_points += score;
}
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}

//定义静态成员函数，访问静态成员变量
int Student::getTotal(){
    return m_total;
}
float Student::getPoints(){
    return m_points;
}

int main(){
    (new Student("小明", 15, 90.6)) -> show();
    (new Student("李磊", 16, 80.5)) -> show();
    (new Student("张华", 16, 99.0)) -> show();
    (new Student("王康", 14, 60.8)) -> show();
    int total = Student::getTotal();
    float points = Student::getPoints();
    cout<<"当前共有"<<total<<"名学生，总成绩是"<<points<<"，平均分是"<<points/total<<endl;
    return 0;
}
```





#### const

const用来定义==值不能改变的变量==，<u>const变量一旦创建就不能再变化，所以const对象必须初始化</u>。

###### 指针常量、常量指针

从右向左看，\*和const按顺序读就是类型的名称*（翻译过来的名称我好像搞反了，但看代码知道意思即可）*。

或者从右向左，把*读成 a pointer to ：

- `int* const p;` p is a const pointer to int，指针是常量
- `int const* p;` p is a pointer to const int，指针指向的是常量
- `const int* p;` p is a pointer to int const，指针指向的是常量，跟上面相同
- `const int* const p;` p is a const pointer to int const，都是常量
- 指向的是常量：普通指针，指向的内容是常量。不能通过指针修改内容，可以修改指针指向的地址。
  - 也称底层const
- 指针是常量：不能修改指向的地址，可以通过指针修改内容。
  - 也称顶层const
- 常量指针常量：都不能。

```c++
const int a = 1, b = 2, c= 3;

// 指向的是常量，可以修改指针指向的地址，不能通过指针修改内容。修改内容可以通过指向别的地址。
const int* p1 = &a;

int const* p2 = &a;

p1 = &b;  // 正确
p2 = &b;  // 正确

p1 = &c;  // 正确
*p1 = 100;  // 错误
p1 = p2;  // 正确



// 指针是常量，可以通过指针修改内容，但不能指向其他地址。
int* const p3 = &a;
p3 = &b;  // 错误
*p3 = 100;  // 正确


// 常量指针常量，不允许修改地址，也不允许修改内容
const int* const p = &a;
*p = 100;  // 错误
p = p2;  // 错误
```

###### const 形参

- `func(const int a){}` 该形参在函数里不能被更改
- <u>常量指针、指针常量的最大用途就是作为函数的形参，保证实参在被调用函数中不被改变</u> 

###### const 修饰类成员函数

- 若指定类的成员函数为const类型，则表明是一个常函数，不能改变类的成员变量。

- 对于类的成员函数，有时必须指定其返回值为const类型，使其返回值不为“左值”





#### #define 和 const

- #define 宏在==<u>预处理阶段</u>==展开，在代码中进行<u>字符串替换</u>（不进行安全检查），不会分配内存，存储于<u>代码段</u>中
- const 常量在==<u>编译阶段</u>==进行<u>类型检查</u>，存储在<u>数据段</u>中的常量区
- #define 不受定义域限制，const 只在定义域内有效





#### static 和 const

- static定义静态变量或方法，强调<u>在内存中只有一份</u>，且可以被共享
  - 函数体内的static变量的作用域为函数体，<u>内存只被分配一次、且函数执行完后不销毁</u>，因此其值在下次调用时仍维持上次的值
  - 模块内的static静态变量和函数可以被同模块内的函数访问，不能被模块外的函数访问
  - 类的static成员变量：被整个类拥有，类的所有对象有一份拷贝，可以不通过对象直接访问
  - 类的static成员函数：主要为了访问类的静态成员变量，不接收this指针，不能访问非静态成员，可以直接调用
- const定义常量，强调<u>不能被改变</u>
  - 阻止一个变量被改变
  - 可以声明常量指针和指针常量
  - 修饰形参表明它是一个输入参数，在函数内不能改变它的值
  - 类的const成员函数：它是一个常函数，不能改变类的成员变量
  - 对于类的成员函数，有时必须指定其返回值为const类型，使其返回值不为“左值”





#### 内联函数

使用inline内联函数，实现频繁调用的短小函数。

优点：

- 在内联函数被调用的地方进行代码展开，==省区函数调用的时间==，提高程序效率
- 相比于宏函数，内联函数在代码展开时，==编译器会进行语法安全检查==

缺点：

- 代码膨胀，更多开销
- 如果内联函数内，代码块的执行时间比调用函数时间长得多，那么效率并没有提升很多
  - 因此适用于短小、频繁调用的函数
- 如果修改内联函数，那么所有调用该函数的代码文件都需重新编译
  - <u>内联声明只是建议，是否内联由编译器决定</u>，所以实际上并不可控





#### 悬挂指针和野指针

- <u>悬挂指针：指针所指向的对象被释放，但指针没有改变，依然指向已被回收的内存地址</u> 
- <u>野指针：未经初始化、不指向对象的指针</u> 

如何避免野指针

- 指针没有被初始化
  - 指针声明时初始化。可以指向具体地址，也可以指向NULL
- 指针p被free或delete后，没有指向对象、也没有置为NULL
  - 指针指向的内存被释放后，指针指向NULL

- 指针操作超过了变量的作用范围
  - 在变量作用域结束前，释放掉变量的地址、指针指向NULL





#### 静态链接，动态链接

- 静态链接：==编译时链接==。在编译链接时，直接将需要执行的代码拷贝到调用处
  - 优点：程序发布时不需要依赖库，可以独立执行
  - 缺点：程序体积相对大；静态库更新后，可执行文件需要重新链接
- 动态链接：==运行时链接==。在编译时不直接拷贝执行代码，而是记录并传给OS，在程序运行到指定代码时，<u>在共享执行内存中寻找已经加载的动态库可执行代码</u>，实现运行时链接
  - 优点：多个程序可共享一个动态库
  - 缺点：由于在运行时加载，可能影响程序的前期执行性能





#### 变量的声明和定义，extern

###### extern

- 声明：<u>不分配地址空间</u> 
  - <u>一个变量可以在多个地方声明</u>，extern修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分进行定义
- 定义：<u>分配变量的地址和存储空间</u> 
  - <u>一个变量只能在一个地方定义</u> 

```c++
int main(){
    extern int a;	// 声明 a 是一个外部变量
}

int a;	// 定义 a，为 a 分配内存空间
```

###### extern "C"

作用是为了实现C++代码调用其他C语言代码。加上 extern "C" 后，会指示编译器按C语言的方式编译这部分代码。主要使用场景：

- C++代码调用C语言代码
- 在C++的头文件中使用
- 在多人协作中，有擅长C语言的人





#### 条件编译

条件编译语句 `#ifdef`、`#endif`、`#else`、`#ifndef` 等

- 将某程序功能模块包括进去，以向特定用户提供该功能，在不需要时用户可将其屏蔽

```c++
#ifdef MATH
#include "math.c"
#endif

#ifdef DEBUG
printf("debug message");
#endif
```

直接使用if语句也可以达到要求，但所有语句都进行编译。<u>使用条件编译，可以减少被编译的语句</u>，从而减少目标程序的长度、减少运行时间。





#### 判断 0

```c++
// 整型
if(n == 0);
if(n != 0);

// 布尔类型
if(b);
if(!b);

// 浮点型，由于二进制存储，小数部位不可避免地有误差
const float EPSINON = 1e-6
if(fabs(f) <= EPSINON);
if(fabs(f) > EPSINON);

// 指针
if(p == nullptr);
if(p != nullptr);
```





#### 深拷贝，浅拷贝

深拷贝和浅拷贝主要针对对象的属性是对象（引用类型）

###### 数据类型的存储

- 基本数据类型：直接存在栈中

- 引用数据类型：在栈中存储地址，真实的数据可能存在堆中

###### 赋值（浅拷贝）时的内存变化

- 当把一个对象赋值给新的变量是，<u>赋值的是对象存在栈中的地址，而不是堆中的数据</u>

- 也就是说，两个对象指向同一个存储空间，无论哪个对象发生改变，都是改变的存储空间的内容，两个对象是联动的

###### 基本类型和引用类型作为函数参数的区别

传参时，栈上开辟空间存储函数的参数，并把实参拷贝到空间中

- <u>对于基本类型，拷贝的是值，函数内修改参数的值</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\6.png" alt="70" style="zoom:67%;" />

- <u>对于引用类型，拷贝的是地址，因此函数会对堆中相应地址的元素直接进行修改</u> 

<img src="C:\Users\acbgzm\Documents\GitHub\MyPostImage\cppnote-img\basic\7.png" alt="70" style="zoom:67%;" />

###### 浅拷贝和深拷贝

默认拷贝构造函数可以完成对象的数据成员简单的复制,这也称为浅拷贝。对象的数据资源是由指针指向的堆时,默认的拷贝构造函数只是将指针复制。

- 结构体可以直接赋值，但当结构体中含有指针“成员”时需要小心，如果进行浅拷贝，不同对象的指针成员都指向同一个位置，当其中一个指针释放内存后，其他指针将悬空，造成内存泄漏





#### sizeof 和 strlen

- sizeof是==操作符==，参数可以是数据的类型 `sizeof(int*);`，计算参数在内存中的大小（占多少Byte）
- strlen是==库函数==，参数只能是以 \0 结尾的字符串，计算字符串的长度而不是内存大小
- 编译器在==编译==时就计算出了sizeof的结果，而strlen函数必须在==运行==时才计算出结果
- 数组作为sizeof参数时不退化，作strlen的参数则退化成指针





#### strcpy，sprintf 和 memcpy

- strcpy<u>实现字符串变量间的拷贝</u>；的两个操作对象均为字符串；执行效率中等
- sprintf<u>实现其他数据类型到字符串的转化</u>；源操作对象可以是多种数据类型，目的操作对象是字符串；执行效率最差
- memcpy<u>实现内存块间的拷贝</u>；两个操作对象是任意可操作的内存地址，不局限于数据类型；执行效率最高





#### volatile

volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会<u>直接从变量在内存的地址中读取数据，而不是去寄存器读取它的备份</u>

volatile在PC软件的多线程中，主要用于<u>修饰临界变量</u>。常修饰：

- 状态寄存器一类的并行设备硬件寄存器
- 一个中断服务子程序会访问到的非自动变量
- 多线程间被几个任务共享的变量

一个参数可以既是const又是volatile吗？

- 可以，同时修饰表示：变量在程序内部是只读的（const），只在程序外部条件变化下改变
- 编译器不会优化这个变量，每次使用时需要从内存读取这个变量的值，而不是去寄存器读取它的备份
- 这里的const只是不允许程序中的代码改变某一变量，在编译期发挥作用。const并不实际地禁止某段内存的读写特性





#### 全局变量和局部变量

- 全局变量是整个程序都可访问的变量，生命周期从程序运行到结束，在程序结束时所占的内存空间被释放
- 局部变量存在于模块（子程序、函数）中，只有所在模块可以访问，模块结束后局部变量所占据的内存被释放
- OS和编译器通过变量存在内存的位置，知道这是局部变量还是全局变量
  - 局部变量存放于堆栈
  - 全局变量存放于全局（静态）数据段，并在重新开始运行的时候被加载





#### 函数指针

- `int* f(int i, int j);` 这是普通函数，返回值是指针 `int*` 
- `int (*p)(int i, int j);` 这是指向函数的指针（函数指针）

函数具有可赋值给指针的物理内存地址

- 一个函数名就是一个指针，指向函数的代码
- 一个函数的地址是该函数的进入点，也是调用函数的地址

函数的调用可以通过函数名，也可以通过指向函数的指针进行调用。函数指针还允许将函数作为变元，传递给其他函数。

定义、赋值、使用语法不拘一格：

```c++
int get_max(int i, int j){}
int get_min(int i, int j){}

int (*p)(int, int);		// 定义
int (*p)(int i, int j);	// 定义

p = get_max;	// 赋值
p = &get_max;	// 赋值

p(a, b);	// 调用
(*p)(a, b);	// 调用
```

###### 例一：

```c++
int get_max(int i, int j){ return i>j?i:j; }
int get_min(int i, int j){ return i<j?i:j; }

int compare(int i, int j, bool flag){   
    // 定义函数指针，根据flag，决定指向哪个函数、并进行调用
    int (*p)(int ,int);
    
    if(flag) p = get_max;
    else p = get_min;
    
    return p(i, j);
}

int main(){
    int i=5, j=10, ans;
    
    ans = compare(i, j, true);
    printf("the max is %d\n", ans);
    
    ans = compare(i, j, false);
    printf("the min is %d\n", ans);
    
    return 0;
}
```

###### 例二（将函数作为变元，传递给其他函数）：

```c++
void check(char* a, char* b, int (*cmp)(const char*, const char*)){
    if((*cmp)(a, b) == 0) printf("equal.\n");
    else printf("not equal.\n");
}

int main(){
    char s1[100], s2[90];
    printf("enter two values or two strings: \n");
    gets(s1);
    gets(s2);
    
    int (*p)(const char*, const char*);
    p = strcmp;		// 用库函数给函数指针赋值
    
    check(s1, s2, p);
    
    return 0;
}
```

###### 例三：

```c++
void compvalues(const char* a, const char* b){
    if(atoi(a) == atoi(b)) return 0;
    else return 1;
}

// check接收函数指针作为参数
void check(char* a, char* b, int (*cmp)(const char*, const char*)){
    if((*cmp)(a, b) == 0)	printf("equal.\n");
    else printf("not equal.\n");
}

int main(){
    char s1[100], s2[90];
    printf("enter two values or two strings: \n");
    gets(s1);
    gets(s2);
    
    // 根据输入的数组类型，把函数指针传给check，调用不同的函数
    if(isdigit(*s1)){
        printf("testing values for equality... \n");
        check(s1, s2, compvalues);
    }
    else{
        printf("testing strings for equality... \n");
        check(s1, s2, strcmp);
    }
    return 0;
}
```





#### 指针和引用的区别

- ==指针是一个对象==，有单独的空间，而==引用只是别名==
- 使用sizeof查看，一个指针的大小是固定的，而引用的大小是被引用对象的大小
- 作为参数传递时，<u>指针需要被解引用才能对对象进行操作</u>，而<u>直接对引用做的修改都会直接改变引用所指向的对象</u>（本质上就是别名）
- 有const指针，没有const引用（引用本身就是必须初始化、不能改变的）
- 指针可以在使用中指向其他对象，引用只能是一个对象的引用，不能改变
- 有多级指针，没有引用的引用
- ++运算符对于指针和引用的意义不同
- 如果返回动态分配的内存或对象，必须使用指针，使用引用会引起内存泄露





#### typedef 和 #define 的区别

- typedef用来定义一种数据类型的别名，增加程序的可读性；#define用来定义常量，以及书写复杂、使用频繁的宏

- #define是宏定义，在<u>预处理</u>阶段起作用，编译器进行简单的<u>字符串替换</u>。#define的代码存储在代码段中

- typedef是编译过程的一部分，有类型检查的功能
- typedef有作用域的限制，#define不受作用域的悦书





#### C的结构体和C++类

区别：

- 结构体不能有成员函数，类可以有
- 结构体默认都是public，类可以有private、public、protected访问限制、默认都是private
- 结构体没有继承关系，类有丰富的继承关系

共同点：

- 内存上，空的都占1字节，含有成员的都按照struct内存对齐方法分配内存





## C++ 面向对象

#### 面向对象三特性

- 封装：将客观事物封装成抽象的类，类可以把数据和方法暴露给可信的类或对象、也可隐藏
- 继承：可以用子类继承父类，子类无需编写代码就具有父类的所有功能，并能进行拓展
- 多态：一个类的实例的相同方法在不同情形下有不同的表现形式，使得不同内部结构的对象可以共享相同的外部接口
  - 静态多态：通过==重载、模板技术==实现，在==编译期间==确定
  - 动态多态：通过==虚函数、继承关系==实现，执行动态绑定，在==运行期间==确定
    - 动态多态的作用
      - 隐藏实现细节，使代码模板化，提高代码的可复用性
      - 接口重用，使派生类的功能可以被基类的指针调用，提高代码的可扩展性、可维护性
    - 动态多态的必要条件
      - 有继承，在继承关系之间体现多态
      - 有虚函数的覆盖，使用父类指针调用子类的功能
      - 有基类指针/引用指向子类对象





#### 动态绑定的实现（虚函数，虚函数表）

当编译器发现类中有虚函数时，会创建虚函数表，把虚函数的入口地址放入虚函数表，并在对象中增加一个vptr，用于指向类的虚函数表。<u>当子类重写基类的虚函数时，会将虚函数表中对应的指针进行替换，从而调用子类覆盖后的虚函数，实现动态绑定</u>。

- 虚函数表存放于常量区
- vptr存放于对象中

虚函数表不针对对象，而是针对类。==类的所有对象共享类的虚函数表==。

- 每个vptr存放在各自对象的内存中，指向相同的地址——虚函数表

###### 构造函数、析构函数

- 构造函数不能是虚函数：调用虚函数需要通过vptr，在虚函数表中找到虚函数的入口，但vptr存放于对象中，不构造就没有vptr
- 析构函数最好是虚函数：
  - 为了实现动态绑定，基类指针指向子类对象
  - 如果析构函数不是虚函数，delete 基类指针时，调用基类的析构函数，子类的内存没有被释放
  - 如果析构函数是虚函数，delete 基类指针时，先调用子类析构函数，再自动调用基类析构函数，释放所有空间

- 构造函数可以抛出异常，但最好别
- 析构函数不能抛出异常：
  - 一旦抛出异常，之后的语句不执行，不会释放内存空间，造成内存泄漏
  - 此外，当异常发生时，C++通常调用析构函数释放资源，但析构函数抛出异常，形成套娃导致程序崩溃

###### 纯虚函数

含有纯虚函数的类是抽象类，不能实例化对象。





#### 多继承

###### 多继承的问题

- 增加程序复杂度
- <u>父类之间，父类和子类之间出现同名成员时，出现同名二义性问题</u>，对成员访问的不确定性
  - 消除同名二义性的方法：
    - 使用作用域运算符 `::`，限定子类使用的是哪个父类的成员
    - 在子类中定义同名成员，覆盖父类的相关成员

- <u>子类从多个父类派生，而这些父类又从同一个基类派生，则在访问共同基类的成员时，会产生路径二义性</u>
  - 消除路径二义性的方法：
    - 消除同名二义性的两种方法都可以，子类再覆盖 或 使用作用域运算符 `::`
    - 使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝

















































## OS

#### 进程，线程

- 写好的程序可以保存在硬盘中。==<u>被CPU读取到内存中，可执行的程序实例叫进程</u>==
  - 在内存中的每个进程，内部都有一个独立的<u>虚拟地址空间</u>。在进程内的通讯可以根据虚拟地址访问，进程间则需要进程间通讯（IPC），可能需要系统调用。每个进程内部是<u>独立</u>的，每个进程都认为自己独占全部的内存空间。
  - <u>进程是系统进行资源分配和调度的基本单位</u>
- 每个进程加载的程序有一个<u>程序计数器</u>，记录当前程序执行的位置。==一个执行流叫线程==。
  - 每个线程有一个程序计数器，还有寄存器、堆栈等运行时的状态信息
  - 线程间<u>共享</u>地址空间、全局变量、打开的文件信息等

- 理解为：多个线程访问同一个文档，并且需要并行执行
- 线程是并行的最小单位，单CPU划分时间片轮转执行
  - 线程的就绪、运行、阻塞状态。进程状态和线程状态原理相同
  - CPU在内存中为每个线程提供虚拟CPU，每个线程认为自己独占CPU



#### 进程间通信

###### 互斥算法：

两个进程同时读取共享变量，容易发生冲突。设置共享变量，进程间互斥访问共享变量，实现进程间通讯。

- 两个进程同时读取共享变量，这部分代码称为临界区。
- 再设置一个==共享变量表示锁==，避免竞争状态

```c++
// 进程A：
while(turn != 0);
critical_region();
trun = 1;
noncritical_region();

// 进程B：
while(turn != 1);
critical_region();
turn = 0;
noncritical_region();
```

###### 同步算法（生产者消费者问题，有界缓冲区问题）：

一个进程向共享区存数据，称为生产者。另一个进程从共享区取数据，称为消费者。

共享区满，生产者不能传数据；共享区空，消费者不能取数据。

设置==共享变量count，标记共享区数量==。

```c++
// 生产者
item = produce_item();
if(count == N) sleep();
insert_item(item);
count ++;
if(count == 1) wakeup(消费者);

// 消费者
if(count == 0) sleep();
item = remouve_item();
count --;
if(count == N-1) wakeup(生产者);
```

设置共享信号量，所有进程可对其进行down、up操作（PV操作）。设置full=0，empty=共享区大小。

```c++
// 生产者
item = produce_item();
down(&empty);
down(&mutex);
insert_item(item);		// 临界区
up(&mutex);
up(&full);

// 消费者
down(&full);
down(&mutex);
item = remove_item();	// 临界区
up(&mutex);
up(&empty);
consume_item(item);
```



#### CPU调度

CPU需要选择下一个运行的进程（或线程），称为CPU调度问题。

###### 进程的分类

- 计算密集型：长时间占用CPU
- I/O密集型：CPU计算时间短，访问外接设备时间长。（现在CPU越来越快，IO密集型越来越多。NodeJS的出现就是应对这类问题。）

###### 调度策略

- 批处理：
  - <u>先来先服务</u>，运行到阻塞态就换下一个，就绪态则排到末尾
    - 问题：计算密集型线程一直占CPU
  - <u>最短作业优先</u>，最短剩余时间优先
- 轮转调度
  - <u>时间片调度</u>：分时间片，在用户态、内核态之间转换
  - <u>优先级调度</u>，<u>多级反馈队列</u>：优先级高的执行，执行完降一级
- 实时系统



#### 内存管理-地址空间

###### memory hierarcy

- Cache高速缓存
- 内存，临时存放运行的程序（进程）。对这一部分进行内存管理。
- 磁盘，可以永久存储

###### 地址空间

每个内存单元大小为1Byte，有一个对应的地址，称为物理地址。

内存管理多进程：

- 需要让多个进程独立，程序指令应该是相对地址而不是物理地址
  - 如果用物理地址进行跳转，会跳转到别的进程中
- OS需要进行进程保护
  - 在执行JMP，跳转到别的进程中的语句时，需要进行保护

因此，需要一种存储器抽象，称为地址空间：设置==基址寄存器==、==界限寄存器==，经过==动态重定位==，将<u>相对地址映射为物理地址</u>。

###### 交换swapping

内存大小有限，进程数量很多，放不下。进程需要<u>暂存到磁盘中，并在内存、磁盘中进行交换</u>。

- 内存紧缩：可以腾出大量的连续内存区域，但移动内存需要耗费大量的CPU时间
- 更好地内存管理算法，在下一节

如何管理这些内存

- 位图：划分成小区域，保存每个区域的空闲/占用状态
- 链表： 四个值，保存是否占用、起始位置、结束位置、next
  - 首次适配first fit：找出第一个空闲区
  - 最佳适配best fit：找出大小最合适的空闲区



#### 内存管理-虚拟内存

上一节的基址寄存器、界限寄存器划分地址空间，现在已经不常用了，因为一整个进程可能装不到内存中。

新方法：虚拟内存。<u>把进程切碎，分页管理，一部分页面在内存中</u>

- 当CPU访问的页面不在内存中，则从磁盘中加载对应部分
- 内存不够时，也可以将长期不访问的页面保存到磁盘中

CPU读取的汇编指令，内存管理单元（MMU）将虚拟地址转换成物理地址，然后通过总线找到相应的内存位置。MMU需要记录虚拟地址到物理地址的映射关系，称为==页表==（使用多级页表，增加映射规模）。

页表通常保存于内存中。MMU每次从内存读取页表很慢，因此MMU中暂存最近使用的部分页表项，叫做转换检测缓冲区（相联存储器，TLB）。







UE4的类

蓝图通信方式

如何实现网络同步，RPC等

unity和ue4





虚指针，虚函数表，虚表是什么数据结构

vptr

TCP可靠，TCP拥塞控制如何实现

右值，forward和move的区别，引用折叠

模板类的迭代器的区别

vector扩容机制和优化方法

拷贝构造函数，深浅拷贝等；如果成员变量中有指针，调用默认拷贝构造函数的问题，自定义拷贝构造函数



大根堆小根堆代码

B树系列，红黑树

