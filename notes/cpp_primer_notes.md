C++ Primer说是职业生涯最重要的一本书也不为过，它本身事无巨细、常看常新，应该经常翻一翻，挑一些细节的地方再看一遍，而不是根据笔记来复习重点；但本着“好记性不如烂笔头”，我在学习的过程中制作了本篇笔记，并且相对详细，当作纪念并且也能做重点复习用。



## 1 章节 

### 1.1 小节 

#### 1.1.1 知识点 

###### 某个方面 

**重点概念** 

<u>需要掌握 </u>

==核心理解关键词== 

~~标注跳转，笔记完成后修改页内链接~~ 





在projects下新建项目即可，自动新建项目文件夹。





## 第1章 开始

### 1.2 初识输入输出

###### 标准输入输出

C++语言未定义任何输入输出语句，取而代之，包含了一个全面的标准库来提供IO机制。

标准库定义了四个IO对象：

- cin：istream类型的对象，处理输入；
- cout：ostream类型的对象，处理输出；
- cerr：ostream类型的对象，输出警告和错误信息；
- clog：ostream类型的对象，输出程序运行时的一般性信息

###### 向流写入数据

输出运算符`<<`接受两个运算对象：左侧是一个ostream对象，右侧是要打印的值，这个运算符的计算结果就是其左侧运算对象。

`endl`是一个被成为操作符（manipulator）的特殊值，写入它的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是停留在内存中等待写入流。

###### 从流读取数据

输入运算符`>>`与输出运算符类似，返回其左侧运算对象，也就是istream对象作为计算结果。

###### 使用标准库中的名字

`std::`指出名字`endl`和`cout`是定义在名为std的命名空间（namespace）中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。

标准库定义的所有名字都在命名空间std中。

### 1.4 控制流

在循环`for(int i=0;i<10;i++){}`的执行流程中，每次执行先检查循环条件 `i<10`，如果满足则执行循环体，最后执行 `i++`。

### 1.5 类简介

包含来自标准库的头文件是，应使用尖括号`#include <iostream>`包围头文件名。对于不属于标准库的头文件，则用双引号`#include "Sales_item.h"`包围。

---

# 第Ⅰ部分 C++基础

任何常用编程语言都具备一组公共的语法特性，包括**内置类型、变量**（第2章）、**表达式和语句、控制结构、函数**（第4到6章）等。此外，大多提供两种方式，来进一步补充基本特性：一是<u>赋予程序员自定义数据类型的权利</u>，从而实现对语言的扩展；二是<u>将一些有用的功能封装成库函数提供给程序员</u>。

对应C++语言：C++允许程序员定义自己的数据类型，称为“类类型（class type）”，类中既包含数据成员，也包含函数成员。C++主要的一个设计目标就是让程序员自定义的数据类型像内置类型一样好用。基于此，标准C++库实现了丰富的类和函数。

本书第Ⅰ部分的主题是学习C++语言的基础知识。第2章详述内置类型；第3章介绍两种最基本的数据类型：字符串和向量，也提及了数组；4到6章分别介绍表达式、语句和函数；第7章描述了如何构建我们自己的类。

## 第2章 变量和基本类型

### 2.1 基本内置类型

C++定义了包括**算术类型**和**空类型**在内的基本数据类型。

#### 2.1.1 算术类型

算术类型分两类：**整形**（包括字符和布尔型）、**浮点型**。算数类型的尺寸在不同机器上有差别，C++标准规定尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

|        类型         |      含义      |       最小尺寸       | **win x86和x64尺寸** |
| :-----------------: | :------------: | :------------------: | :------------------: |
|        bool         |    布尔类型    |        未定义        |      1byte 8bit      |
|        char         |      字符      |         8位          |      1byte 8bit      |
|       wchar_t       |     宽字符     |         16位         |                      |
|      char16_t       |  Unicode字符   |         16位         |                      |
|      char32_t       |  Unicode字符   |         32位         |                      |
|        short        |     短整型     |         16位         |     2byte 16bit      |
|         int         |      整型      |         16位         |     4byte 32bit      |
|        long         |     长整型     |         32位         |     4byte 32bit      |
| long long（C++ 11） |     长整型     |         64位         |     8byte 64bit      |
|        float        |  单精度浮点数  |  6位有效数字（8位）  |     4byte 32bit      |
|       double        |  双精度浮点数  | 10位有效数字（12位） |     8byte 64bit      |
|     long double     | 扩展精度浮点数 | 10位有效数字（12位） |                      |

###### 整型

- 基本数据类型是char，一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个char的大小和一个机器字节（Byte）一样。
- 其它字符类型用于扩展字符集，wchar_t确保可以存放机器最大扩展字符集中的任意一个字符，char16_t和char32_t为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准）。
- 除了字符和布尔类型外，其他整型用于表示不同尺寸的整数。
- 除了bool和扩充的char类型，其他整型可以分为带符号的和无符号的两种，加上unsigned的无符号整型所有bit都用来表示值，所以无符号整型只能表示≥0的值。

###### 机器实现

- 可寻址最小内存块：字节（byte），存储的基本单元：字（word）
- 在32位机器：1word=4byte=32bit，在64位机器：1word=8byte=64bit
- 计算机将每个字节（byte）跟一个地址关联起来。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。类型决定了数据占的地址数，以及如何解释这些地址的内容。

###### 浮点型

- 浮点型可表示单精度、双精度、扩展精度，大多数编译器都扩展了C++标准指定的最小精度。
- 通常，float以1个字（32bit）表示，double以2个字（64bit）表示，long double以3或4个字表示（96或128bit）。
- 通常，float和double分别有7和16个有效位，long double则常用于有特殊浮点要求的硬件，精度跟具体实现有关。

###### 代码01-typeofsize.cpp，可以看x64各数据类型的size大小。一些发现：

- x64下，空struct本身占8bit。
- 一个含有1doube、1int、1char的struct共占16byte，推测8byte的double+4byte的int+1byte的char+1byte的struct。
- 一个含有1double、2int、1char的struct共占24byte，推测struct的size是根据最大元素的尺寸，乘以倍数得来的。
- 指针不管指向什么类型的地址，x86指针4byte32bit，x64指针8byte64bit。

###### 关于选择类型的建议

- 明确知晓数值不可能为负时，选用unsigned类型
- 使用int执行整数运算，超过int范围就选择long long
- 在算术表达式中不要使用bool和char。char在一些机器上有符号，在一些机器上无符号，容易出问题。
- 执行浮点数运算使用double，double比float精度高且计算代价相差无几。

#### 2.1.2 类型转换

###### 类型转换

- 赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数，如把-1赋给8bit的unsigned char，得到的结果是(-1%256)=255。
- 当赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。
- 把非布尔值赋给布尔变量，<u>是0则布尔值为false，否则都为true</u>。
- 要注意不要给unsigned类型赋负数值，也要避免此类运算。尤其是：算数表达式中既有有符号又有无符号，有符号会转变成无符号进行计算。int+unsigned int时，int会变成无符号进行运算，容易出现负int转换错误。

#### 2.1.3 字面值常量

###### 字面值常量

- 整形和浮点数：
  -  `20`十进制，`024`八进制，`0x14`十六进制 
  - `3.14149`，`3.14.59E0`，`0.`，`0e0`，`.001` 
- 字符和字符串：`'char'`，`"string"`，字符串的长度比字面上的长度多1，因为会在尾部加一个`\0`

###### 转义序列

- 一些不可打印字符，如退格或其他控制字符，它们没有可视的图符；另一类有特殊含义的字符，如引号、问好、反斜线等，需要转用到转义序列。
- 也可以使用泛化的转义字符。`\x`后跟多个十六进制数字，或`\`后跟最多3个八进制数字。

###### 指定字面值的类型

- char类型用前缀：`u8"hi!"`
- 整型、浮点型用后缀：`3.14159L`，`40ULL`



### 2.2 变量

#### 2.2.1 变量定义

- 定义：`int sum`
- 定义并赋初值：`int sum=0;`，`std::string book("0-201-78345-X")`（用string类型的预定义方法，把字符串字面值拷贝给string对象）
- **初始化不是赋值**，初始化的含义是<u>创建变量时赋予其一个初始值</u>，而赋值的含义是<u>把对象的当前值擦除并附一个新值</u>。

###### 列表初始化

```c++
long double ld = 3.141459;
int a{ld}, b={ld};  // 错误：转换未执行，因为存在丢失信息的风险
int c(ld), d=(ld);  // 正确：转换执行，且确实丢失了部分信息
```

用long double值去初始化int变量，这种初始化可能在不经意间发生，~~见3.2.1和3.3.1~~。

###### 默认初始化

- 定义于任何函数体之外的变量被初始化为0
- 定义在函数体内的内置类型变量不被初始化（main函数里定义个int也不行）。每个类自己决定初始化对象的方式
- 总结：定义于函数体内的内置类型的对象如果没有初始化，则其值未定义；类的对象如果没有显式地初始化，则其值由类决定。
- <u>建议初始化每一个内置类型的变量</u>

#### 2.2.2 变量声明和定义的关系

分离式编译：允许将程序分割成若干个文件，每个文件可被独立编译。分离式编译在2.6.3和6.1.3详细讲解。

- 声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字，则必须包含对那个名字的声明
  - 规定变量的类型和名字 `extern int i;`
- 定义（definition）负责创建与名字关联的实体
  - 申请存储空间，也可能赋初始值 `int j;`
  - 包含显式初始化的声明也成了定义，`extern double pi = 3.1416;`
- <u>变量能且只能被定义一次，但可以被声明多次</u>
  - 在多个文件使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现、且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，绝对不能重复定义
- C++是静态类型语言，其含义是在编译阶段检查类型。编译器检查数据类型是否支持要执行的运算。程序越复杂，静态类型检查越有助于发现问题。

#### 2.2.3 标识符

- C++标识符（identifier）必须以字母或下划线开头，可以包含数字，对长度没有限制。

- C++保留一些名字供语言本身使用。同时也为标准保留了一些名字。
- 用户自定义标识符不能出现连续两个下划线、不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头（~~我试了一下好像都可以了，疑似C++11或更新特性~~）。

###### 变量命名规范

- 变量名一般用小写字母，如 index
- 用户自定义类名一般以大写字母开头，如 Sales_item
- 由多个单词组成，要做区分，student_loan 或 studentLoan

#### 2.2.4 名字的作用域

C++中一般以花括号作为作用域分界线。

- main函数定义在左右花括号之外，它的作用域就和大多数定义在函数体之外的名字一样，拥有*全局作用域*。在整个程序的范围内都可使用。
- 在main函数里定义的名字，除了main函数所在的块就无法访问了，拥有*块作用域*。
- 建议：<u>当第一次使用变量时再去定义它</u>
- 嵌套作用域：作用域定义一个名字，它的内层作用域都可以使用，并可以重新定义这个名字。使用域操作符`::`覆盖默认的作用域规则，左侧为空时就代表全局作用域。
- 建议：<u>不要再定义跟全局变量同名的局部变量</u>



### 2.3 复合类型

复合类型指基于其他类型的类型。本章介绍两种：引用和指针。·	

#### 2.3.1 引用 - ==不是对象，别名==

*此处只说左值引用。C++11的新特性右值引用在~~13.6.1~~。*

- <u>引用并非对象，它只是为对象起一个别名</u>
- <u>引用必须被初始化</u>
  - 一般在初始化变量时，初始值被**拷贝**到新建的对象中。然而定义引用时，程序把引用和它的初始值**绑定（bind）**到一起，而不将初始值拷贝给引用。
  - 并且，一旦初始化完成，会一直绑定在一起，因为无法令引用重新绑定到另一个对象，因此引用必须初始化。

```c++
int ival = 1024;
int& refVal = ival;
int& refVal2;  // 报错
refVal = 2;
int ii = refVal;  // 相当于 ii = ival
```

- 定义一个引用后，对其进行的所有操作都是在与之绑定的对象上进行的。（因为引用并非对象）
  - 对引用赋值，实际上是把值赋给绑定的对象
  - 获取引用值，实际上是获取绑定的对象的值

```c++
int& refVal3 = refVal;
int i = refVal;
```

- 还是因为引用并非对象，不能定义引用的引用。引用的**初始值**必须是一个**对象**，不能是引用，也不能是常量、表达式等。

```c++
int& refVal4 = 10;  // 报错
int& refVal5 = refVal;  // 报错
```

- 除了特殊情况（~~2.4.1，15.2.3~~），其他所有引用的类型都要和与之绑定的对象严格匹配。

#### 2.3.2 指针 - ==是对象，地址==

指针是指向另一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。

- **指针本身就是一个对象**
  - 存放指针指向的对象的地址
  - 允许对指针赋值、拷贝
  - 生命周期内，指针可以仙后指向几个不同的对象
- **指针无须在定义时赋初值**
  - 如果没初始化则拥有一个不确定的值

###### 获取对象的地址

指针存放某个对象的地址。要想获取该地址，使用取地址符`&`。

因为引用不是对象，没有实际地址，所以<u>不能定义指向引用的指针</u>。

除了~~2.4.2、15.2.3~~介绍的两种例外情况外，所有指针类型都要和它指向的对象严格匹配。

```c++
double dval;
double* pd = &dval;
double* pd2 = pd;

int* pi = pd;  // 错误：pi是int型指针，pd是double型指针
pi = &dval;    // 错误：不能将double型对象的地址赋值给int指针
```

###### 指针值

指针的值（即地址）属于下列四种之一：

- 1 指向一个对象
- 2 指向紧邻对象所占空间的下一个位置
- 3 空指针，意味着指针没有指向任何对象
- 4 无效指针，也就是上述情况之外的其他值

①试图拷贝或以其他形式访问 4 无效指针的值，会引发错误；②2、3 指针没有指向任何具体内容，访问此类指针（假定的）对象的行为不被允许。

①这类错误跟使用未经初始化的变量是一样的，编译器不负责检查此类错误。因此**程序员必须清楚任意给定的指针是否有效**。

###### 利用指针访问对象

使用解引用符`*`访问指针指向的对象。

给解引用的结果赋值，实际上也就是通过指针、给指针所指的对象赋值。

###### 空指针

几个生成空指针的方法：

-  `int *p1 = nullptr;` - C++11：使用字面值`nullptr`初始化指针，可以得到一个空指针
- `int *p2 = 0;` - 将指针初始化为字面值0，可以生成空指针
- `int *p3 = NULL;` - 跟上一条等价，`NULL`是一个预处理变量，它的值就是0，需`#include<cstdlib>`。预处理变量不属于命名空间std，因此无需加上std::（在2.6.3介绍关于预处理器的知识）。<u>在新标准下，最好使用`nullptr`，避免使用`NULL`</u>。

```c++
// int* i = 1; // 错误，不能给指针直接赋常量值，必须指向对象
int* ii = 0; // 正确，赋0值的意思是创建空指针
```

在试图使用一个指针之前，代码可以<u>首先检查它是否为空</u>。

建议：**初始化所有指针**。尽量等<u>定义了对象，然后再定义指向它的指针</u>。如果实在不清楚指针应指向何处，就<u>初始化为`nullptr`或`0`</u>。

###### 赋值和指针

指针和引用都能提供对其他对象的间接访问，但实现细节上二者不同：引用本身并非对象，一旦定义引用，就不能再绑定到别的对象；而指针跟其他任何变量（只要不是引用）一样，给指针赋值就是令他存放一个新的地址，从而指向一个新的对象。

```c++
int i = 42;
int* pi = 0;	// pi被初始化为空指针
int* pi2 = &i;	// pi2指向i的地址
int* pi3;		// pi3没有被初始化

pi3 = pi2;		// pi3跟pi2一样，指向i的地址
pi2 = 0;		// pi2现在变为空指针了，不指向任何地址
```

有时候想搞清一条赋值语句到底是改变了指针的值，还是改变了指针所指向对象的值不容易，最好的办法就是记住**赋值语句永远改变的是等号左边的对象**。

```c++
pi = &val;		// 改变指针的值，也就是存放的地址
*pi = 0;		// 使用解引用符访问指针指向的对象，改变对象的值
```

###### 其他指针操作

只要指针拥有一个合法值，就能将它用在条件表达式中。

- 如果指针值为0则为false，否则为true

```c++
int ival = 1024;
int* pi = 0; 		// 空指针
int* pi2 = &ival;	// 合法指针
if(pi)				// pi值为0，条件的值为false
	// ...
if(pi2)				// 值不为0，条件的值为true
	// ... 
```

- 可以用相等操作比较两个指针，如果存放的地址值相同，则它们相等
  - 地址相同的三种可能性：都为空；都指向同一对象；都指向同一对象的下一个地址
  - 一个指针指向某对象，另一个指针指向另外一个对象的下一个地址，它们也有可能指向同一个位置，即两个指针相等

不论作为条件还是比较，都需要用到指针的值，因此要求<u>必须使用合法指针</u>。

~~3.5.3节~~介绍更多关于指针的操作

###### void*指针

void*是一种特殊的指针类型，可用于<u>存放任意对象的地址</u>。它存放着一个地址，但<u>我们对该地址中到底是什么类型的对象并不了解</u>。

```c++
double obj = 3.14, *pd = &obj;
void* pv = &obj;	// void*指针可以存放任意类型的地址，obj可以是任意类型的对象
pv = *pd;			// pv可以存放任意类型的指针
```

利用void\*能做的事情比较少：<u>拿它跟别的指针比较、作为函数的输入和输出、赋值给另外一个void\*指针</u>。

<u>不能直接操作void*指针所指向的对象</u>，因为我们不知道它是什么类型，自然不知道对象上定义了哪些操作。

概括说：以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中存储的对象。

关于这点，在~~19.1.1节~~有更详细的介绍，~~4.11.3节~~将讲述获取void\*指针所存地址的方法



### 2.4 const限定符

### 2.5 处理类型

### 2.6 自定义数据结构

