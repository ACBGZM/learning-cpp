## 计算机网络

#### 计算机网络的发展

<img src="C:\Users\acbgzm\Desktop\面试准备\image\90.png" style="zoom:50%;" />

- 最基础的想法：两两相连，通过高低信号传输信息
- 物理层-==集线器==
  - 所有设备跟集线器通信，集线器将消息广播，每台设备查看是否是发给自己
  - 缺点：
    - 数据进行广播，带宽利用率低
    - 同时只能有一个设备发送数据，链路利用率低（同时发送会造成信息混合，使用CSMA/CD只在空闲时发送）



<img src="C:\Users\acbgzm\Desktop\面试准备\image\91.png" style="zoom:50%;" />

- 数据链路层-==交换机==
  - 提出了==MAC地址==的概念，实现了小规模的全双工定向通信
  - 优点：可以在比较小的局域网络内部高效传输
    - 会<u>记录MAC地址和交换机端口的映射关系</u>（大小几千条），不用广播
    - 使用网线（有8根线），可以全双工
  - 缺点：
    - 最多记录几千个路由信息，无法大规模定向通信
  - 数据包：头+数据，头包括原MAC地址和目的MAC地址



<img src="C:\Users\acbgzm\Desktop\面试准备\image\92.png" style="zoom:50%;" />

- 交换机满足了小规模局域网内部的互通，但互联网的目的是跨局域网，如何联通两个网络？

- 网络层-==路由器==（网关）
  - 网络是比较抽象的概念，提出==IP地址==概念
    - 标识网络本身、标识设备
    - 比如路由器对内的IP地址是192.168.0.1，可以连接的设备IP地址是192.168.0.102，对外的IP地址是192.168.1.52
  - 路由器存储一个路由表，<u>标记每个网络的IP地址和路由器端口的映射关系</u>。
    - 建立路由表的算法是目前的研究内容之一
    - 路由表实现了网络间的传输
  - IP地址是抽象的地址，不像MAC地址一样，不能直接用于通信
  - 网络内的数据包如何传输？如从192.168.1.52发送到192.168.1.254
    - 通过ARP协议，查IP地址为192.168.1.254对应的MAC地址
    - 网络内依然在数据链路层进行传输
  - 数据包：IP的整个数据包作为MAC的数据字段。IP包里也可能还有TCP、HTTP等数据头。



- 传输层-TCP、UDP等，保障数据的可靠性
- 应用层-HTTP等特定应用场景下的协议

<img src="C:\Users\acbgzm\Desktop\面试准备\image\93.png" style="zoom:50%;" />



#### TCP和UDP

- TCP：基于连接
  - 三次握手
    - 客户端到服务器：发送SYN包，询问能否建立连接
    - 服务器到客户端：发送SYN+ACK包，同意连接
    - 客户端到服务器：发送ACK包，建立连接
    - 不两次握手的原因：防止已失效的请求报文突然传到服务器，引起错误。
      - （第三次看作确实是我在前面发起了申请，否则随便一个包发服务器就会建立连接）
  - 传输确认
  - 四次挥手
    - 客户端到服务器：发送FIN包，客户端进入FIN-WAIT-1状态
    - 服务器到客户端：发送ACK包，服务器进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态
    - 服务器到客户端此时可以发送未发送完的数据，客户端可以接收数据
    - 服务器到客户端：发送FIN包，服务器进入LAST-ACK状态
    - 客户端到服务器：发送ACK包，进入TIME-WAIT超时等待状态，时间到后关闭连接，服务器收到ACK包立即关闭连接
      - 进入超时等待时间是为了确保服务器收到ACK包。如果服务器没收到，会重发FIN包，超时等待期间收到FIN包就重发ACK包
- UDP：基于非连接，性能损耗少、快、自定义程度高















## OS

#### 系统架构，指令集

<img src="C:\Users\acbgzm\Desktop\面试准备\image\94.png" style="zoom:50%;" />



#### 进程、线程、协程

- 进程是一个运行中的程序，==进行资源的获取==。
  - 一个进程跟很多资源产生交互，如：文件、硬件、CPU、内存、进程信息、权限信息等
  - 但进程执行只需要CPU和内存
- 抽象出一个更小的单位：线程。==进行程序的执行==
  - 所有进程在启动后，都会有一个主线程
  - OS不再把计算资源给进程，而是直接给线程。线程是CPU调度时间片的最小单位
- <u>OS不用使用树状结构存储进程-线程之间的包含关系</u>，而是可以直接分两张表单独存储进程和线程。因为进程进行资源管理，线程负责执行程序，相互是独立的。

- 不同语言调用不同的线程，要映射到OS的统一kernel threads。
- 为了进一步提高线程的利用率，在<u>高IO、多个小任务的场景下，会创建很多Routine</u>。==Routine是轻量级的线程，切换成本更低，降低了直接在多个线程之间切换的成本==。
- 协程就是Routine的一种实现。





#### 用户态和内核态

- 指的是程序运行中的状态
- ==用户无法直接操作硬件，OS通过内核态操作硬件，并把结果返回用户== 
- 用户态 -> 内核态
  - 申请外部资源（主板上的USB、内存，机箱里的LED等都是外部资源）
    - 系统调用
      - 进程 exit，fork
      - 文件 chmod，chow
      - 设备 read，write
      - 信息 get xxx
      - 通信 pipe，mmap
    - 中断
    - 异常
  - 举例
    - 读写文件，用到open/read/write系统调用
      - open、read、write既是C语言中的方法，也是系统调用
    - malloc 申请虚拟内存空间，并在第一次调用时触发缺页中断，更新页表
      - 通过brk系统调用（≤128K会在堆空间申请内存）
      - 通过mmap系统调用（＞128K会在堆栈中间申请）



#### OS的内存管理

##### 为什么要有逻辑地址的概念？为什么不直接操作物理地址？

- 程序无法知道可用的物理地址，多进程访问内存时无法确定物理地址的可用性，因此要有逻辑地址跟物理地址之间的映射。

##### 如何进行逻辑地址和物理地址的映射？

###### 一个方法：分页

- 逻辑地址分多个页page，物理内存分多个页帧page frame

- 使用页表，存储页到页帧的映射关系。==页表存在内存中== 
- 每个进程都维护自己单独的页表，映射到同一块物理内存中
- 分页使每个程序都有很大的逻辑地址空间
  - 由于内存的一个地址是一个Byte，32位OS的物理地址共2^32=4GB，==任何32位程序都认为自己独占内存空间即可操作4GB的逻辑地址==，会造成：多个程序使用的内存总和大于物理内存
  - 此时会借助磁盘，将不着急使用的页先放到磁盘，磁盘跟内存进行页的交换

- 逻辑地址到物理地址的映射举例：32位系统、256MB内存、页大小4KB，逻辑地址0x000011a3
  - 逻辑地址方面：4KB = 12位，12位存储页内偏移，因此逻辑地址 32b = 20b页号 + 12b页内偏移 
    - 0x000011a3 = 页号 00001 + 页内偏移 1a3
    - 查找页表页号 00001 的帧号，在帧中+1a3的偏移，找到对应的物理地址
    - 如果帧号在磁盘中，会触发缺页异常、OS进入内核态，内核在磁盘中找到对应数据、放到内存的页帧中、重新填写页表，重新进行映射
  - 物理地址方面：256MB = 28位，12b偏移，因此物理地址 28b = 16b帧号 + 12b帧内偏移

<img src="C:\Users\acbgzm\Desktop\面试准备\image\95.png" style="zoom:50%;" />

##### 分页的优化

- ==分页使程序有很大的逻辑空间、使不同进程的内存隔离、降低了内存碎片问题，但由于页表存储在内存，一方面占空间，另一面需要两次读内存（先读页表，再找页帧）==
  - 时间上优化，TLB：将最常访问的页表项存到访问速度更快的硬件中（一般是MMU内存管理单元）
  - 空间上优化，多级页表

##### 程序内部的内存管理-分段

- 最早期的分段将程序分成几个大的内存区域，然后每个段包含若干页，每个段逻辑地址都从0开始，页表要存储段号-页号-页帧号
  - 这种方法已基本上被抛弃，x86-64不使用段页结合而是只分页
- 在编程中的“段错误”、“堆栈”等段的概念，其实是==逻辑上的概念==，不在内存管理中起作用
  - 如图，32位的程序，虚拟内存空间是4GB
  - 从高到低依次是：1GB的内核区、栈区、共享库区、堆区、数据区（全局静态区）、字符串常量区
    - 共享库区用于进程间共享内存来相互通信，包含动态链接库dll、malloc调用mmap等
    - malloc若申请＞128K的内存，会调用mmap，在堆和栈之间的区域申请内存，也就是图中的lib区。它们都是页映射磁盘（mmap就是文件映射内存的系统调用）

<img src="C:\Users\acbgzm\Desktop\面试准备\image\96.png" style="zoom:50%;" />

<img src="C:\Users\acbgzm\Desktop\面试准备\image\97.png" style="zoom:50%;" />



#### 从下到上的内存

###### 内存条、总线、DMA

- 总线在主板内，分IO总线、地址总线、数据总线、PCIE总线、USB等。

- CPU和内存条都直接插在主板上，有直接相连的总线
  - 直接通过数据总线进行数据交互
  - 为了找到数据在内存条中的地址，还需要有地址总线

- DMA集成在南桥芯片
  - 读取文件等操作可以通过DMA控制器读取，不会直接占用CPU，因此NodeJS等单线程的语言也可以实现一边读文件、一边执行其他语句。（IO异步）
  - CPU把读文件的任务交给DMA控制器时，也同时移交了总线控制权，此时DMA就可以读写内存，并且CPU对总线没有控制权了
  - DMA并不是在读文件过程中一直掌握总线控制权，而是进行轮换（分时复用），使CPU能执行其他一些任务，如鼠标输入等

###### 操作系统的内存管理和分类

- 内存管理（详见上面）：程序都认为自己独享整块虚拟内存空间，虚拟内存是连续的，但通过页表映射到物理空间上可能是不连续的，甚至可能不在内存中而在磁盘上。

- 分类

  linux

  <img src="C:\Users\acbgzm\Desktop\面试准备\image\99.png" style="zoom:50%;" />

  windows

<img src="C:\Users\acbgzm\Desktop\面试准备\image\98.png" style="zoom: 50%;" />

已提交：申请的内存 / 总内存+swap

已缓存：对应Linux的Buffer cache

###### 内存相关的系统调用

- ==brk：在堆上申请内存空间==。C语言封装的函数`sbrk()`。
  - brk默认一次申请一页内存。

假设一页4KB：

```c
int* first = (int*)sbrk(1);	// 实际上申请了一页
*(first+1) = 123;	// 在5~8存一个int
printf("%d", *(first+1));	// 不会报错，因为实际上申请了一页，可以对其中的内存进行操作
```

```c
int* second = (int*)sbrk(1);	// 实际上申请了一页
*(second+1024) = 123;	// 在4096~存一个int
printf("%d", *(second+1024));	// 段错误
```

- mmap
  - 图中触发了100次缺页（小错误），也就是进行了100次申请页面
  - mmap主要是用来直接读文件到内存，懒加载机制会触发一次大错误，将文件加载到内存页面中。后面的小错误再将虚拟内存映射到物理内存上 

<img src="C:\Users\acbgzm\Desktop\面试准备\image\100.png" style="zoom: 50%;" />

<img src="C:\Users\acbgzm\Desktop\面试准备\image\102.png" style="zoom: 50%;" />



- mmap和read读文件
  - read系统调用进入内核态，进行文件读取、将文件内容加载到kernel space，再拷贝到用户空间，再切换回用户态，用户就可以读取这部分文件的内容了
  - mmap直接将文件进行映射，先在页表中填写磁盘空间（惰性的，直接把文件的磁盘地址填到页表中），然后在程序读取页表时触发缺页，将文件加载到内存中
    - 这几个页面由内核空间和用户空间两部分都映射到相同文件所对应的物理内存中
    - mmap省去了从内核空间到用户空间拷贝的过程
  - mmap不能利用buffer cache，并且第一次触发的缺页异常也会耗时，跟read没有绝对的性能好坏

<img src="C:\Users\acbgzm\Desktop\面试准备\image\101.png" style="zoom: 50%;" />























